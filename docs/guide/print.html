<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Shadow Simulator</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="shadow.html">The Shadow Simulator</a></li><li class="chapter-item expanded "><a href="design_2x.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="security.html"><strong aria-hidden="true">1.1.</strong> Non-goal: Security</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Installation Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="supported_platforms.html"><strong aria-hidden="true">2.1.</strong> Supported Platforms</a></li><li class="chapter-item expanded "><a href="install_dependencies.html"><strong aria-hidden="true">2.2.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="install_shadow.html"><strong aria-hidden="true">2.3.</strong> Shadow</a></li><li class="chapter-item expanded "><a href="system_configuration.html"><strong aria-hidden="true">2.4.</strong> System Configuration</a></li><li class="chapter-item expanded "><a href="install_shadow_with_docker.html"><strong aria-hidden="true">2.5.</strong> (Experimental) Shadow with Docker</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Usage Guide</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="run_shadow_overview.html"><strong aria-hidden="true">3.1.</strong> Overview</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Running Your First Simulations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started_basic.html"><strong aria-hidden="true">3.2.1.</strong> Basic File Transfer</a></li><li class="chapter-item expanded "><a href="getting_started_tgen.html"><strong aria-hidden="true">3.2.2.</strong> Traffic Generation</a></li><li class="chapter-item expanded "><a href="getting_started_tor.html"><strong aria-hidden="true">3.2.3.</strong> Simple Tor Network</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Understanding Shadow Output</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="log_format.html"><strong aria-hidden="true">3.3.1.</strong> Format of the Log Messages</a></li><li class="chapter-item expanded "><a href="parsing_shadow_logs.html"><strong aria-hidden="true">3.3.2.</strong> Parsing Statistics from the Logs</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Configuring Your Own Simulation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="shadow_config_overview.html"><strong aria-hidden="true">3.4.1.</strong> Shadow Config Overview</a></li><li class="chapter-item expanded "><a href="shadow_config_spec.html"><strong aria-hidden="true">3.4.2.</strong> Shadow Config Specification</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Configuring Your Own Network</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="network_graph_overview.html"><strong aria-hidden="true">3.5.1.</strong> Network Graph Overview</a></li><li class="chapter-item expanded "><a href="network_graph_spec.html"><strong aria-hidden="true">3.5.2.</strong> Network Graph Specification</a></li></ol></li><li class="chapter-item expanded "><a href="migrating_from_1x.html"><strong aria-hidden="true">3.6.</strong> Migrating Simulations from Shadow 1.x</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.7.</strong> Performance Tuning</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="sidechannels.html"><strong aria-hidden="true">3.7.1.</strong> Disabling Side-channel Mitigations</a></li><li class="chapter-item expanded "><a href="parallel_sims.html"><strong aria-hidden="true">3.7.2.</strong> Parallel Simulations</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Developer Guides</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="developer_guide.html"><strong aria-hidden="true">4.1.</strong> Debugging and profiling</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">4.2.</strong> Continous integration tests</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">5.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="coding_style.html"><strong aria-hidden="true">5.1.</strong> Coding style</a></li><li class="chapter-item expanded "><a href="pull_requests.html"><strong aria-hidden="true">5.2.</strong> Pull requests</a></li></ol></li><li class="chapter-item expanded "><a href="maintainer_playbook.html"><strong aria-hidden="true">6.</strong> Maintainer playbook</a></li><li class="chapter-item expanded "><a href="nsf_sponsorship.html"><strong aria-hidden="true">7.</strong> NSF Sponsorship</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Shadow Simulator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/shadow/shadow" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-shadow-simulator"><a class="header" href="#the-shadow-simulator">The Shadow Simulator</a></h1>
<h2 id="what-is-shadow"><a class="header" href="#what-is-shadow">What is Shadow?</a></h2>
<p>Shadow is a discrete-event network simulator that directly executes real
application code, enabling you to simulate distributed systems with thousands of
network-connected processes in <strong>realistic</strong> and <strong>scalable</strong> private network
experiments using your laptop, desktop, or server running Linux.</p>
<p>Shadow experiments can be scientifically <strong>controlled</strong> and deterministically
<strong>replicated</strong>, making it easier for you to reproduce bugs and eliminate
confounding factors in your experiments.</p>
<h2 id="how-does-shadow-work"><a class="header" href="#how-does-shadow-work">How Does Shadow Work?</a></h2>
<p>Shadow directly executes <strong>real applications</strong>:</p>
<ul>
<li>Shadow directly executes unmodified, real application code using native OS
(Linux) processes.</li>
<li>Shadow co-opts the native processes into a discrete-event simulation by
interposing at the system call API.</li>
<li>The necessary system calls are emulated such that the applications need not
be aware that they are running in a Shadow simulation.</li>
</ul>
<p>Shadow connects the applications in a <strong>simulated network</strong>:</p>
<ul>
<li>Shadow constructs a private, virtual network through which the managed
processes can communicate.</li>
<li>Shadow internally implements simulated versions of common network protocols
(e.g., TCP and UDP).</li>
<li>Shadow internally models network routing characteristics (e.g., path latency
and packet loss) using a configurable network graph.</li>
</ul>
<h2 id="why-is-shadow-needed"><a class="header" href="#why-is-shadow-needed">Why is Shadow Needed?</a></h2>
<p>Network emulators (e.g., <a href="http://mininet.org">mininet</a>) run real application
code on top of real OS kernels in real time, but are non-determinsitic and have
limited scalability: time distortion can occur if emulated processes exceed an
unknown computational threshold, leading to undefined behavior.</p>
<p>Network simulators (e.g., <a href="https://www.nsnam.org">ns-3</a>) offer more experimental
control and scalability, but have limited application-layer realism because they
run application abstractions in place of real application code.</p>
<p>Shadow offers a novel, hybrid emulation/simulation architecture: it directly
executes real applications as native OS processes in order to faithfully
reproduce application-layer behavior while also co-opting the processes into a
high-performance network simulation that can scale to large distributed systems
with hundreds of thousands of processes.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>Shadow implements <strong>over 150 functions from the system call API</strong>, but does not
yet fully support all API features. Although applications that make <em>basic</em> use
of the supported system calls should work out of the box, those that use more
<em>complex</em> features or functions (e.g., <code>fork()</code>) may not yet function correctly
when running in Shadow. Extending support for the API is a work-in-progress.</p>
<p>That being said, we are particularly motivated to run large-scale <a href="https://www.torproject.org">Tor
Network</a> simulations. This use-case is already
fairly well-supported and we are eager to continue extending support for it.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Build, test, and install Shadow into <code>~/.local</code>:</p>
<pre><code>$ ./setup build --clean --test
$ ./setup test
$ ./setup install
</code></pre>
<h2 id="more-information"><a class="header" href="#more-information">More Information</a></h2>
<p>Homepage:</p>
<ul>
<li>https://shadow.github.io</li>
</ul>
<p>Detailed Documentation:</p>
<ul>
<li><a href="docs/README.html">Local user documentation in docs/README.md</a></li>
<li><a href="https://shadow.github.io/docs/guide">Online user documentation</a></li>
<li><a href="https://shadow.github.io/docs/rust">Online developer documentation</a></li>
</ul>
<p>Community Support:</p>
<ul>
<li>https://github.com/shadow/shadow/discussions</li>
</ul>
<p>Bug Reports:</p>
<ul>
<li>https://github.com/shadow/shadow/issues</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadow-2x-design"><a class="header" href="#shadow-2x-design">Shadow 2.x Design</a></h1>
<p><em>TODO: This document should be expanded.</em></p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Shadow directly executes real applications using native OS processes and co-opts
them into a high-performance discrete-event network simulation. Shadow enables
realistic and scalable private network experiments that can be scientifically
controlled and deterministically replicated.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>What about ns-3? <a href="https://www.nsnam.org">ns-3</a> is a network simulator that is
designed to replicate network-layer protocol behavior with very high fidelity.
It contains accurate reimplementations of many network layer protocols and
communication substrates, and is thus targeted primarily for use by researchers
designing new network-layer protocols or protocol features. It does not (really)
support running unmodified, real applications, leaving users to implement
synthetic application abstraction models in place of real application code.</p>
<p>What about mininet? <a href="http://mininet.org">mininet</a> is a network emulator that is
designed to run real kernel, switch, and application code in real time. The real
time requirement severely limits the number of processes that can be run in a
mininet experiment: time distortion can occur if the processes exceed a
computational threshold, which can result in undefined behavior and artifacts
that lead to untrustworthy results.</p>
<p>Shadow aims to fill the gap between these tools. Like mininet, Shadow directly
executes real applications in order to faithfully reproduce application
behavior. But like ns-3, Shadow runs a discrete-event simulation in order to
scientifically control and deterministically replicate network experiments.
Shadow uniquely targets experiments with large-scale distributed systems and
thus our simulator design prioritizes high-performance computing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-goal-security"><a class="header" href="#non-goal-security">Non-goal: Security</a></h1>
<p>Never run code under Shadow that you wouldn't trust enough to run outside of
Shadow on the same system at the same level of privilege.</p>
<p>While Shadow uses some of the same techniques used by other systems to isolate
potentially vulnerable or malicious software, this is <em>not</em> a design goal of
Shadow. A managed program in a Shadow simulation can, if it tries to, detect
that it's running under such a simulation and break out of the &quot;sandbox&quot; to
issue native system calls.</p>
<p>For example:</p>
<ul>
<li>Shadow currently doesn't restrict access to the host file
system. A malicious managed program can read and modify the same files that
Shadow itself can.</li>
<li>Shadow inserts some code via <code>LD_PRELOAD</code> into managed processes. This code
intentionally has the ability to make non-interposed system calls (which it uses
to communicate with the Shadow process), and makes no effort to protect itself
from the managed code running in the same process.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h1>
<h2 id="officially-supported-platforms"><a class="header" href="#officially-supported-platforms">Officially supported platforms</a></h2>
<ul>
<li>Ubuntu 18.04 and 20.04</li>
<li>Debian 10</li>
<li>Fedora 34</li>
<li>CentOS Stream 8</li>
</ul>
<p>If you are installing Shadow within a Docker container, you must increase the
size of the container's <code>/dev/shm</code> mount by passing <code>--shm-size=&quot;1g&quot;</code> (with a
suitable size for your system and experiments) to <code>docker run</code>.</p>
<p>If you are having difficulty installing Shadow on any of these platforms, you
may find the <a href="https://github.com/shadow/shadow/blob/main/.github/workflows/run_tests.yml">continuous integration build
steps</a>
helpful.</p>
<p>We do not provide official support for other platforms. This means that we do
not ensure that Shadow successfully builds and passes tests on other platforms.
However, we will review pull requests that allow Shadow to build and run on
unsupported platforms.</p>
<h2 id="known-incompatible-platforms"><a class="header" href="#known-incompatible-platforms">Known incompatible platforms</a></h2>
<ul>
<li>CentOS 7: We rely on features of glibc that aren't available on CentOS 7. Shadow won't compile there
due to our use of C11 atomics, and threaded virtual processes running with
preload-based interposition will deadlock due to an incompatible implementation
of thread-local-storage.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-dependencies"><a class="header" href="#installing-dependencies">Installing Dependencies</a></h1>
<h3 id="required"><a class="header" href="#required">Required:</a></h3>
<ul>
<li>gcc, gcc-c++ (or clang, clang++)</li>
<li>python (version &gt;= 3.6)</li>
<li>glib (version &gt;= 2.32.0)</li>
<li>igraph (version &gt;= 0.5.4)</li>
<li>cmake (version &gt;= 3.2)</li>
<li>make</li>
<li>xz-utils</li>
<li>procps</li>
<li>cargo, rustc (version ~ latest)</li>
</ul>
<h3 id="recommended-python-modules-for-helperanalysis-scripts"><a class="header" href="#recommended-python-modules-for-helperanalysis-scripts">Recommended Python Modules (for helper/analysis scripts):</a></h3>
<ul>
<li>numpy, scipy, matplotlib, networkx, lxml, pyyaml</li>
</ul>
<h3 id="recommended-system-tools"><a class="header" href="#recommended-system-tools">Recommended System Tools:</a></h3>
<ul>
<li>git, dstat, htop, tmux</li>
</ul>
<h2 id="apt-debianubuntu"><a class="header" href="#apt-debianubuntu">APT (Debian/Ubuntu):</a></h2>
<pre><code class="language-bash"># required dependencies
sudo apt-get install -y \
    cmake \
    findutils \
    libc-dbg \
    libglib2.0-0 \
    libglib2.0-dev \
    libigraph0-dev \
    libigraph0v5 \
    libprocps-dev \
    make \
    python3 \
    python3-pip \
    xz-utils \
    gcc \
    g++

# rustup: https://rustup.rs
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# optional python modules
sudo apt-get install -y \
    python3-numpy \
    python3-lxml \
    python3-matplotlib \
    python3-networkx \
    python3-scipy \
    python3-yaml

# optional tools
sudo apt-get install -y \
    dstat \
    git \
    htop \
    tmux
</code></pre>
<h2 id="yum-fedoracentos"><a class="header" href="#yum-fedoracentos">YUM (Fedora/CentOS):</a></h2>
<p>Before running these commands, please check any platform-specific
requirements below.</p>
<p><strong>Warning:</strong> <code>dnf</code> often installs 32-bit (<code>i686</code>) versions of
libraries. You may want to use the <code>--best</code> option to make sure you're
installing the 64-bit (<code>x86_64</code>) versions, which are required by Shadow.</p>
<pre><code class="language-bash"># required dependencies
sudo dnf install -y \
    cmake \
    findutils \
    glib2 \
    glib2-devel \
    igraph \
    igraph-devel \
    make \
    procps-devel \
    python3 \
    python3-pip \
    xz \
    xz-devel \
    yum-utils \
    diffutils \
    gcc \
    gcc-c++

# rustup: https://rustup.rs
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# optional python modules
sudo dnf install -y \
    python3-numpy \
    python3-lxml \
    python3-matplotlib \
    python3-networkx \
    python3-scipy \
    python3-yaml

# optional tools
sudo dnf install -y \
    dstat \
    git \
    htop \
    tmux
</code></pre>
<h3 id="centos-stream-8"><a class="header" href="#centos-stream-8">CentOS Stream 8</a></h3>
<p>As procps-ng-devel, igraph, and igraph-devel are not available on CentOS Stream 8, you
must install them manually.</p>
<pre><code class="language-bash">dnf remove -y procps-ng procps-ng-devel
dnf install -y http://vault.centos.org/centos/7.7.1908/os/x86_64/Packages/procps-ng-3.3.10-26.el7.x86_64.rpm
dnf install -y http://vault.centos.org/centos/7.7.1908/os/x86_64/Packages/procps-ng-devel-3.3.10-26.el7.x86_64.rpm
dnf install -y https://dl.fedoraproject.org/pub/archive/epel/7.7/x86_64/Packages/i/igraph-0.7.1-12.el7.x86_64.rpm
dnf install -y https://dl.fedoraproject.org/pub/archive/epel/7.7/x86_64/Packages/i/igraph-devel-0.7.1-12.el7.x86_64.rpm
</code></pre>
<p>Due to <a href="https://bugs.centos.org/view.php?id=18212">a bug</a> in the CentOS 8 CMake
package, you must also install libarchive manually.</p>
<pre><code class="language-bash">dnf install -y libarchive
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadow-setup"><a class="header" href="#shadow-setup">Shadow Setup</a></h1>
<p>After building and testing Shadow, the install step is optional. If you do not
wish to install Shadow, you can run it directly from the build directory
(<code>./build/src/main/shadow</code>).</p>
<pre><code class="language-bash">git clone https://github.com/shadow/shadow.git
cd shadow
./setup build --clean --test
./setup test
# Optionally install (to ~/.local/bin by default). Can otherwise run the binary
# directly at build/src/main/shadow.
./setup install
</code></pre>
<p>For the remainder of this documentation, we assume the Shadow binary is in your
<code>PATH</code>. The default installed location of <code>/home/${USER}/.local/bin</code> is
probably already in your <code>PATH</code>. If it isn't, you can add it by running:</p>
<pre><code class="language-bash">echo 'export PATH=&quot;${PATH}:/home/${USER}/.local/bin&quot;' &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc
</code></pre>
<p>Check that Shadow is installed and runs:</p>
<pre><code class="language-bash">shadow --version
shadow --help
</code></pre>
<h2 id="uninstall-shadow"><a class="header" href="#uninstall-shadow">Uninstall Shadow</a></h2>
<p>After running <code>./setup install</code>, you can find the list of installed files in
<code>./build/install_manifest.txt</code>. To uninstall Shadow, remove any files listed.</p>
<h2 id="setup-notes"><a class="header" href="#setup-notes">Setup Notes</a></h2>
<ul>
<li>
<p>All build output is generated out-of-source, by default to the <code>./build</code>
directory.</p>
</li>
<li>
<p>Use <code>./setup build --help</code> to see all build options; some useful build
options are:</p>
<ul>
<li><code>-g</code> or <code>--debug</code> to build Shadow with debugging symbols</li>
<li><code>--include</code> and <code>--library</code> if you installed any dependencies in
non-standard locations or somewhere other than <code>~/.local</code>.</li>
<li><code>--prefix</code> if you want to install Shadow somewhere besides <code>~/.local</code></li>
</ul>
</li>
<li>
<p>The <code>setup</code> script is a wrapper to <code>cmake</code> and <code>make</code>. Using <code>cmake</code> and
<code>make</code> directly is also possible, but unsupported. For example:</p>
<pre><code class="language-bash"># alternative installation method
rm -r build &amp;&amp; mkdir build &amp;&amp; cd build
cmake -DCMAKE_INSTALL_PREFIX=&quot;~/.local&quot; -DSHADOW_TEST=ON ..
make
ctest
make install
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-configs-and-limits"><a class="header" href="#system-configs-and-limits">System Configs and Limits</a></h1>
<p>Some Linux system configuration changes are needed to run large-scale Shadow
simulations (more than about 1000 processes).</p>
<h2 id="number-of-open-files"><a class="header" href="#number-of-open-files">Number of Open Files</a></h2>
<p>There is a default linux system limit on the number of open files. If each
process in your Shadow virtual host opens many file or socket descriptors (if
you have many hosts, this is very likely to happen), you'll likely want to
increase the limit so you application doesn't start getting errors when calling
<code>open()</code> or <code>socket()</code>.</p>
<h3 id="system-wide-limits"><a class="header" href="#system-wide-limits">System-wide Limits</a></h3>
<p>Check the <em>system-wide</em> limits with:</p>
<pre><code class="language-bash">sysctl fs.nr_open # per-process open file limit
sysctl fs.file-max # system-wide open file limit
</code></pre>
<p>Use <code>cat /proc/sys/fs/file-nr</code> to find:</p>
<ol>
<li>the current, system-wide number of used file handles</li>
<li>the current, system-wide number of free file handles</li>
<li>and the system-wide limit on the maximum number of open files for all processes</li>
</ol>
<p>Change the limits, persistent across reboots, and apply now:</p>
<pre><code class="language-bash">sysctl -w fs.nr_open=10485760
echo &quot;fs.nr_open = 10485760&quot; &gt;&gt; /etc/sysctl.conf
sysctl -w fs.file-max=10485760
echo &quot;fs.file-max = 10485760&quot; &gt;&gt; /etc/sysctl.conf
sysctl -p
</code></pre>
<h3 id="user-limits"><a class="header" href="#user-limits">User Limits</a></h3>
<p>Check the maximum number of open file descriptors <em>currently allowed</em> in your
session:</p>
<pre><code class="language-bash">ulimit -n
</code></pre>
<p>Check the number of files <em>currently used</em> in a process with pid=PID:</p>
<pre><code class="language-bash">/bin/ls -l /proc/PID/fd/ | wc -l
</code></pre>
<p>You will want to almost certainly want to raise the user file limit by modifying
<code>/etc/security/limits.conf</code>. For example:</p>
<pre><code>rjansen soft nofile 10485760
rjansen hard nofile 10485760
</code></pre>
<p>The max you can use is your <code>fs.nr_open</code> system-wide limit setting from above.
You need to either log out and back in or reboot for the changes to take affect.
You can watch <code>/proc/sys/fs/file-nr</code> and reduce the limit according to your
usage, if you'd like.</p>
<h3 id="systemd-limits"><a class="header" href="#systemd-limits">systemd Limits</a></h3>
<p>systemd may place a limit on the number of tasks that a user can run in its
slice. You can check to see if a limit is in place by running</p>
<pre><code>$ systemctl status user-$UID.slice
</code></pre>
<p>Here's a listing of an example response:</p>
<pre><code>● user-1027.slice - User Slice of &lt;user&gt;
   Loaded: loaded
Transient: yes
  Drop-In: /run/systemd/system/user-1027.slice.d
           └─50-After-systemd-logind\x2eservice.conf, 50-After-systemd-user-sessions\x2eservice.conf, 50-Description.conf, 50-TasksMax.conf
   Active: active since Wed 2020-05-06 21:20:08 EDT; 1 years 2 months ago
    Tasks: 81 (limit: 12288)
</code></pre>
<p>The last line of the listing shows that this user has a task limit of 12288
tasks.</p>
<p>If this task limit is too small, it can be removed with the following command:</p>
<pre><code>$ sudo systemctl set-property user-$UID.slice TasksMax=-1
</code></pre>
<h2 id="number-of-maps"><a class="header" href="#number-of-maps">Number of Maps</a></h2>
<p>There is a system limit on the number of <code>mmap()</code> mappings per process. Most
users will not have to modify these settings. However, if an application running
in Shadow makes extensive use of <code>mmap()</code>, you may need to increase the limit.</p>
<h3 id="process-limit"><a class="header" href="#process-limit">Process Limit</a></h3>
<p>The process limit can be queried in these ways:</p>
<pre><code class="language-bash">sysctl vm.max_map_count
cat /proc/sys/vm/max_map_count
</code></pre>
<p>You can check the number of maps currently used in a process with pid=PID like
this:</p>
<pre><code class="language-bash">wc -l /proc/PID/maps
</code></pre>
<p>Set a new limit, make it persistent, apply it now:</p>
<pre><code class="language-bash">sudo sysctl -w vm.max_map_count=1073741824
sudo echo &quot;vm.max_map_count = 1073741824&quot; &gt;&gt; /etc/sysctl.conf
sudo sysctl -p
</code></pre>
<h2 id="process--thread-count-limits"><a class="header" href="#process--thread-count-limits">Process / Thread Count Limits</a></h2>
<h3 id="system-wide-limits-1"><a class="header" href="#system-wide-limits-1">System-Wide Limits</a></h3>
<p>The kernel may limit the max-pid value to a small value, which will limit the
total number of possible processes running on the machine. This limit can be
raised by the command</p>
<pre><code class="language-bash">sudo sysctl -w kernel.pid_max=4194304
sudo echo &quot;kernel.pid_max = 4194304&quot; &gt;&gt; /etc/sysctl.conf
sudo sysctl -p
</code></pre>
<p>The kernel may also limit the total number of threads running on the machine.
This limit can be raised, too.</p>
<pre><code class="language-bash">sudo sysctl -w kernel.threads-max=4194304
sudo echo &quot;kernel.threads-max = 4194304&quot; &gt;&gt; /etc/sysctl.conf
sudo sysctl -p
</code></pre>
<p>The kernel may cap the <code>kernel.threads-max</code> value automatically so that, in the
maximum limit, the memory consumed by kernel thread control structures do not
consume more than approx. (1/8)th of system memory (see
<a href="https://stackoverflow.com/a/21926745">https://stackoverflow.com/a/21926745</a>).</p>
<h3 id="user-limits-1"><a class="header" href="#user-limits-1">User Limits</a></h3>
<p>You may need to raise the maximum number of user processes allowed in
<code>/etc/security/limits.conf</code>. For example, user limits can be removed with the
lines:</p>
<pre><code>rjansen soft nproc unlimited
rjansen hard nproc unlimited
</code></pre>
<h2 id="for-more-information"><a class="header" href="#for-more-information">For more information</a></h2>
<p>https://www.kernel.org/doc/Documentation/sysctl/fs.txt<br />
https://www.kernel.org/doc/Documentation/sysctl/vm.txt</p>
<pre><code class="language-bash">man proc
man ulimit
cat /proc/sys/fs/file-max
cat /proc/sys/fs/inode-max
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-from-the-dockerfile"><a class="header" href="#run-from-the-dockerfile">Run from the Dockerfile</a></h1>
<ol>
<li>Install docker from https://docs.docker.com/engine/install/.</li>
<li>Build container:</li>
</ol>
<pre><code>git clone https://github.com/shadow/shadow.git
cd shadow
docker build . -t shadow --shm-size=&quot;1g&quot;
</code></pre>
<ol start="3">
<li>Run tests:</li>
</ol>
<pre><code>docker run --shm-size=&quot;1g&quot; --privileged --rm --entrypoint /src/ci/container_scripts/test.sh shadow
</code></pre>
<h2 id="run-a-simulation"><a class="header" href="#run-a-simulation">Run a simulation</a></h2>
<p>To be able to run a simulation you have to mount a volume with the simulation
dependencies (configurations and binaries). This will generate a log directory
owned by <code>root</code>.</p>
<p>For example, the next command runs the <code>shadow.config.xml</code> simulation present in
the current path:</p>
<pre><code>docker run --shm-size=&quot;1g&quot; --privileged --rm --log-driver=none -v $(pwd):/src/ shadow --interpose-method=ptrace -l debug shadow.config.xml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-shadow-overview"><a class="header" href="#running-shadow-overview">Running Shadow Overview</a></h1>
<p>When installing Shadow, the main executable was placed in <code>/bin</code> in your install
prefix (<code>~/.local/bin</code> by default). As a reminder, it would be helpful if this
location was included in your environment <code>PATH</code>.</p>
<p>The main Shadow binary executable, <code>shadow</code>, contains most of the simulator's
code, including events and the event engine, the network stack, and the routing
logic. Shadow's event engine supports multi-threading using the <code>-p</code> or
<code>--parallelism</code> flags (or their corresponding <a href="shadow_config_spec.html#generalparallelism">configuration file
option</a>) to simulate multiple hosts
in parallel.</p>
<p>Shadow can typically run applications without modification, but there are a few
limitations to be aware of:</p>
<ul>
<li>Not all system calls are supported yet. Notable unsupported syscalls include
fork and exec.</li>
<li>Applications should not use or expect signals.</li>
<li>Shadow does not support IPv6.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-basic"><a class="header" href="#getting-started-basic">Getting Started Basic</a></h1>
<p>Here we present a basic example that simulates the network traffic of an HTTP
server with 3 clients, each running on different virtual hosts. If you do not
have Python or cURL installed, you can download them through your distribution's
package manager.</p>
<h2 id="configuring-the-simulation"><a class="header" href="#configuring-the-simulation">Configuring the Simulation</a></h2>
<p>Each client uses cURL to make an HTTP request to a basic Python HTTP server.</p>
<p>Shadow requires a configuration file that specifies information about the
network graph and the processes to run within the simulation. This example
uses a built-in network graph for simplicity.</p>
<p><code>shadow.yaml</code>:</p>
<pre><code class="language-yaml">general:
  # stop after 10 simulated seconds
  stop_time: 10s

network:
  graph:
    # use a built-in network graph containing
    # a single vertex with a bandwidth of 1 Gbit
    type: 1_gbit_switch

hosts:
  # a host with the hostname 'server'
  server:
    processes:
    - path: /bin/python3
      args: -m http.server 80
      start_time: 3s
  # three hosts with hostnames 'client1', 'client2', and 'client3'
  client:
    quantity: 3
    processes:
    - path: /bin/curl
      args: -s server
      start_time: 5s
</code></pre>
<h2 id="running-the-simulation"><a class="header" href="#running-the-simulation">Running the Simulation</a></h2>
<p>Shadow stores simulation data to the <code>shadow.data</code> directory by default. We
first remove this directory if it already exists, and then run Shadow.</p>
<pre><code class="language-bash"># delete any existing simulation data
rm -rf shadow.data
shadow shadow.yaml &gt; shadow.log
</code></pre>
<p>This small Shadow simulation should complete almost immediately.</p>
<h2 id="viewing-the-simulation-output"><a class="header" href="#viewing-the-simulation-output">Viewing the Simulation Output</a></h2>
<p>Shadow will write simulation output to the data directory (in this example we'll
assume the default directory of <code>shadow.data</code>). Each host has its own directory
under <code>shadow.data/hosts</code>. For example:</p>
<pre><code class="language-bash">$ ls -l shadow.data/hosts
drwxrwxr-x 2 user user 4096 Jun  2 16:54 client1
drwxrwxr-x 2 user user 4096 Jun  2 16:54 client2
drwxrwxr-x 2 user user 4096 Jun  2 16:54 client3
drwxrwxr-x 2 user user 4096 Jun  2 16:54 server
</code></pre>
<p>Each host directory contains the output for each process running on that host. For example:</p>
<pre><code class="language-bash">$ ls -l shadow.data/hosts/client1
-rw-rw-r-- 1 user user   1 Jun  2 16:54 client1.curl.1000.exitcode
-rw-rw-r-- 1 user user   0 Jun  2 16:54 client1.curl.1000.shimlog
-rw-r--r-- 1 user user   0 Jun  2 16:54 client1.curl.1000.stderr
-rw-r--r-- 1 user user 542 Jun  2 16:54 client1.curl.1000.stdout

$ cat shadow.data/hosts/client1/client1.curl.1000.stdout
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;title&gt;Directory listing for /&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Directory listing for /&lt;/h1&gt;
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-tgen"><a class="header" href="#getting-started-tgen">Getting Started TGen</a></h1>
<p><em>We recommend getting started with the <a href="getting_started_basic.html">basic file
transfer</a> before running this example, because it
contains some basics about running Shadow simulations that are not covered
here.</em></p>
<p>During Shadow simulations, it is often useful to generate background traffic
flows between your simulated hosts. This example uses the <a href="https://github.com/shadow/tgen">TGen traffic
generator</a> for this purpose.</p>
<p>TGen is capable of generating basic file transfers, where you can configure how
much data is transferred in each direction, how long to wait in between each
transfer, and how many transfers to perform. TGen also supports more complex
behavior models: you can use Markov models to configure a state machine with
precise inter-packet timing characteristics. We only make use of its basic
features in this example.</p>
<p>If you don't have it installed, you can follow the <a href="https://github.com/shadow/tgen/#setup">instructions
here</a>. The following example runs TGen
with 10 clients that each download 10 files from a server over a simple network
graph.</p>
<h2 id="a-shadow-simulation-using-tgen"><a class="header" href="#a-shadow-simulation-using-tgen">A Shadow Simulation using TGen</a></h2>
<p>The following examples simulates a network with 1 TGen server and 10 TGen clients
that are generating TCP traffic to and from the server.</p>
<h3 id="configuring-shadow"><a class="header" href="#configuring-shadow">Configuring Shadow</a></h3>
<p>The <code>shadow.yaml</code> file instructs Shadow how to model the network that is used to
carry the traffic between the hosts, and about the bandwidth available to each
of the hosts. It also specifies how many processes to run in the simulation, and
the configuration options for those applications.</p>
<p><code>shadow.yaml</code>:</p>
<pre><code class="language-yaml">general:
  stop_time: 10m

network:
  graph:
    # a custom single-node graph
    type: gml
    inline: |
      graph [
        node [
          id 0
          bandwidth_down &quot;140 Mbit&quot;
          bandwidth_up &quot;18 Mbit&quot;
        ]
        edge [
          source 0
          target 0
          latency &quot;50 ms&quot;
          packet_loss 0.01
        ]
      ]
hosts:
  server:
    processes:
    - path: ~/.local/bin/tgen
      args: ../../../tgen.server.graphml.xml
      start_time: 1s
  client:
    quantity: 10
    processes:
    - path: ~/.local/bin/tgen
      args: ../../../tgen.client.graphml.xml
      start_time: 2s
</code></pre>
<p>We can see that Shadow will be running 11 processes in total, and that those
processes are configured using <code>graphml.xml</code> files (the configuration file
format for TGen) as arguments.</p>
<p>Each host directory is also the <a href="https://en.wikipedia.org/wiki/Working_directory">working
directory</a> for the host's
processes, which is why we specified <code>../../../tgen.server.graphml.xml</code> as the
path to the TGen configuration in our Shadow configuration file
(<code>./shadow.data/hosts/server/../../../tgen.server.graphml.xml</code> →
<code>./tgen.server.graphml.xml</code>).</p>
<h3 id="configuring-tgen"><a class="header" href="#configuring-tgen">Configuring TGen</a></h3>
<p>Each TGen process requires an action-dependency graph in order to configure the
behavior of the clients and server. See the <a href="https://github.com/shadow/tgen/tree/main/doc">TGen
documentation</a> for more
information about customizing TGen behaviors.</p>
<h4 id="our-tgen-server"><a class="header" href="#our-tgen-server">Our TGen Server</a></h4>
<p>The main configuration here is the port number on which the server will listen.</p>
<p><code>tgen.server.graphml.xml</code>:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;graphml xmlns=&quot;http://graphml.graphdrawing.org/xmlns&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&quot;&gt;
  &lt;key attr.name=&quot;serverport&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d1&quot; /&gt;
  &lt;key attr.name=&quot;loglevel&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d0&quot; /&gt;
  &lt;graph edgedefault=&quot;directed&quot;&gt;
    &lt;node id=&quot;start&quot;&gt;
      &lt;data key=&quot;d0&quot;&gt;info&lt;/data&gt;
      &lt;data key=&quot;d1&quot;&gt;8888&lt;/data&gt;
    &lt;/node&gt;
  &lt;/graph&gt;
&lt;/graphml&gt;
</code></pre>
<h4 id="our-tgen-clients"><a class="header" href="#our-tgen-clients">Our TGen Clients</a></h4>
<p>The client config specifies that we connect to the server using its name and
port <code>server:8888</code>, and that we download and upload <code>1 MiB</code> 10 times, pausing 1,
2, or 3 seconds between each transfer.</p>
<p><code>tgen.client.graphml.xml</code>:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;graphml xmlns=&quot;http://graphml.graphdrawing.org/xmlns&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd&quot;&gt;
  &lt;key attr.name=&quot;recvsize&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d5&quot; /&gt;
  &lt;key attr.name=&quot;sendsize&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d4&quot; /&gt;
  &lt;key attr.name=&quot;count&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d3&quot; /&gt;
  &lt;key attr.name=&quot;time&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d2&quot; /&gt;
  &lt;key attr.name=&quot;peers&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d1&quot; /&gt;
  &lt;key attr.name=&quot;loglevel&quot; attr.type=&quot;string&quot; for=&quot;node&quot; id=&quot;d0&quot; /&gt;
  &lt;graph edgedefault=&quot;directed&quot;&gt;
    &lt;node id=&quot;start&quot;&gt;
      &lt;data key=&quot;d0&quot;&gt;info&lt;/data&gt;
      &lt;data key=&quot;d1&quot;&gt;server:8888&lt;/data&gt;
    &lt;/node&gt;
    &lt;node id=&quot;pause&quot;&gt;
      &lt;data key=&quot;d2&quot;&gt;1,2,3&lt;/data&gt;
    &lt;/node&gt;
    &lt;node id=&quot;end&quot;&gt;
      &lt;data key=&quot;d3&quot;&gt;10&lt;/data&gt;
    &lt;/node&gt;
    &lt;node id=&quot;stream&quot;&gt;
      &lt;data key=&quot;d4&quot;&gt;1 MiB&lt;/data&gt;
      &lt;data key=&quot;d5&quot;&gt;1 MiB&lt;/data&gt;
    &lt;/node&gt;
    &lt;edge source=&quot;start&quot; target=&quot;stream&quot; /&gt;
    &lt;edge source=&quot;pause&quot; target=&quot;start&quot; /&gt;
    &lt;edge source=&quot;end&quot; target=&quot;pause&quot; /&gt;
    &lt;edge source=&quot;stream&quot; target=&quot;end&quot; /&gt;
  &lt;/graph&gt;
&lt;/graphml&gt;
</code></pre>
<h3 id="running-the-simulation-1"><a class="header" href="#running-the-simulation-1">Running the Simulation</a></h3>
<p>With the above three files saved in the same directory, you can start a
simulation. Shadow stores simulation data to the <code>shadow.data</code> directory by
default. We first remove this directory if it already exists, and then run
Shadow. This example may take a few minutes.</p>
<pre><code class="language-bash"># delete any existing simulation data
rm -rf shadow.data
shadow shadow.yaml &gt; shadow.log
</code></pre>
<h3 id="simulation-output"><a class="header" href="#simulation-output">Simulation Output</a></h3>
<p>Shadow will write simulation output to the data directory (in this example we'll
assume the default directory of <code>shadow.data</code>). Each host has its own directory
under <code>shadow.data/hosts</code>.</p>
<p>In the TGen process output, lines containing <code>stream-success</code> represent
completed downloads and contain useful timing statistics. From these lines we
should see that clients have completed a total of <strong>100</strong> streams:</p>
<pre><code class="language-bash">for d in shadow.data/hosts/client*; do grep &quot;stream-success&quot; ${d}/*.stdout ; done | wc -l
</code></pre>
<p>We can also look at the transfers from the servers' perspective:</p>
<pre><code class="language-bash">for d in shadow.data/hosts/server*; do grep &quot;stream-success&quot; ${d}/*.stdout ; done | wc -l
</code></pre>
<p>You can also parse the TGen output logged to the stdout files using the
<code>tgentools</code> program from the TGen repo, and plot the data in graphical format to
visualize the performance characteristics of the transfers. <a href="https://github.com/shadow/tgen/blob/main/doc/Tools-Setup.md">This
page</a> describes how
to get started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-tor"><a class="header" href="#getting-started-tor">Getting Started Tor</a></h1>
<p><em>We recommend getting started with the <a href="getting_started_basic.html">basic file
transfer</a> and <a href="getting_started_tgen.html">traffic
generation</a> examples to orient yourself with Shadow
before running this slightly more complex Tor simulation.</em></p>
<p>This example requires that you have installed (or linked) a Tor executable in
<code>~/.local/bin/tor</code> (see <a href="https://github.com/torproject/tor/blob/main/README">the Tor install
README</a>). You also need to
install (or link) a TGen executable in <code>~/.local/bin/tgen</code> (see <a href="https://github.com/shadow/tgen">the TGen
installation guide</a>).</p>
<p>Once Shadow, Tor, and TGen are installed, you can quickly get started running a
very simple Tor network:</p>
<pre><code class="language-bash">cd shadow/src/test/tor/minimal
./run.sh
./verify.sh
</code></pre>
<p>The <a href="../src/test/tor/minimal/run.sh"><code>run.sh</code> script</a> launches Shadow with a
config that runs a minimal Tor network. The <a href="../src/test/tor/minimal/verify.sh"><code>verify.sh</code>
script</a> checks that all Tor processes
bootstrapped correctly and that all TGen file transfer attempts succeeded. Note
that these steps can also be launched as a test case using <code>./setup test -- --build-config extra --label tor</code>.</p>
<p>After the experiment, have a look in the <code>shadow.data/host/*</code> directories to
inspect the individual log files from the Tor relays and TGen clients.</p>
<p>You can use the <a href="https://github.com/shadow/tornettools">tornettools
toolkit</a> to run larger, more
complex Tor networks that are meant to more accurately resemble the
characteristics and state of the public Tor network.</p>
<h2 id="determinism"><a class="header" href="#determinism">Determinism</a></h2>
<p>Shadow isn't able to natively intercept all sources entropy that tor uses via
openssl, which results in non-deterministic results. If you'd like better
determinism for your simulation, you can use the provided auxiliary library,
libshadow_openssl_rng, whichoverride's some of openssl's RNG routines.</p>
<p>To do so, add the full path to the library to the <code>LD_PRELOAD</code> in each tor
process's <code>environment</code>.  If you've installed Shadow to the default location,
the path should be <code>home/&lt;username&gt;/.local/lib/libshadow_openssl_rng.so</code>.</p>
<pre><code>...
hosts:
  torclient:
    processes:
      - path: ~/.local/bin/tor
        # Must provide absolute path. See #1523.
        environment: 'LD_PRELOAD=/home/&lt;username&gt;/.local/lib/libshadow_openssl_rng.so'
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format-of-shadow-log-messages"><a class="header" href="#format-of-shadow-log-messages">Format of Shadow Log Messages</a></h1>
<h2 id="log-line-prefix"><a class="header" href="#log-line-prefix">Log Line Prefix</a></h2>
<p>Shadow produces simulator log messages in the following format:</p>
<pre><code class="language-text">real-time [thread-name] virtual-time [loglevel] [hostname:ip] [src-file:line-number] [function-name] MESSAGE
</code></pre>
<ul>
<li><code>real-time</code>:<br />
the wall clock time since the start of the experiment, represented as
<code>hours:minutes:seconds</code></li>
<li><code>thread-name</code>:<br />
the name of the system thread that generated the message</li>
<li><code>virtual-time</code>:<br />
the simulated time since the start of the experiment, represented as
<code>hours:minutes:seconds</code></li>
<li><code>loglevel</code>:<br />
one of <code>ERROR</code> &lt; <code>WARN</code> &lt; <code>INFO</code> &lt; <code>DEBUG</code> &lt; <code>TRACE</code>, in that order</li>
<li><code>hostname</code>:<br />
the name of the host as specified in <code>hosts.&lt;hostname&gt;</code> of the simulation
config</li>
<li><code>ip</code>:<br />
the IP address of the host as specified in <code>hosts.&lt;hostname&gt;.ip_address_hint</code>
of the simulation config, or a random IP address if one is not specified</li>
<li><code>src-file</code>:<br />
the name of the source code file where the message is logged</li>
<li><code>line-number</code>:<br />
the line number in the source code file where the message is logged</li>
<li><code>function-name</code>:<br />
the name of the function logging the message</li>
<li><code>MESSAGE</code>:<br />
the actual message to be logged</li>
</ul>
<p>By default, Shadow only prints core messages at or below the <a href="shadow_config_spec.html#generallog_level"><code>info</code> log
level</a>. This behavior can be changed
using the Shadow option <code>-l</code> or <code>--log-level</code> to increase or decrease the
verbosity of the output. As mentioned in the example from the previous section,
the output from each application process is stored in separate log files beneath
the <code>shadow.data</code> directory, and the format of those log files is
application-specific (i.e., Shadow writes application output <em>directly</em> to
file).</p>
<h2 id="heartbeat-messages"><a class="header" href="#heartbeat-messages">Heartbeat Messages</a></h2>
<p>Shadow logs simulator heartbeat messages that contain useful system information
for each virtual node in the experiment, in messages containing the string
<code>shadow-heartbeat</code>. By default, these heartbeats are logged once per second, but
the frequency can be changed using the <code>--heartbeat-frequency</code> option to Shadow
(see <code>shadow --help</code>).</p>
<p>There are currently three <a href="shadow_config_spec.html#host_defaultsheartbeat_log_info">heartbeat statistic
subsystems</a>: <code>node</code>,
<code>socket</code>, and <code>ram</code>. For each subsystem that is enabled, Shadow will print a
'header' message followed by regular message every frequency interval. The
'header' messages generally describe the statistics that are printed in the
regular messages for that subsystem.</p>
<p>The following are examples of the statistics that are available for each
subsystem:</p>
<p>Node:</p>
<pre><code>[node-header] interval-seconds,recv-bytes,send-bytes,cpu-percent,delayed-count,avgdelay-milliseconds;inbound-localhost-counters;outbound-localhost-counters;inbound-remote-counters;outbound-remote-counters where counters are: packets-total,bytes-total,packets-control,bytes-control-header,packets-control-retrans,bytes-control-header-retrans,packets-data,bytes-data-header,bytes-data-payload,packets-data-retrans,bytes-data-header-retrans,bytes-data-payload-retrans
</code></pre>
<p>Socket:</p>
<pre><code>[socket-header] descriptor-number,protocol-string,hostname:port-peer;inbuflen-bytes,inbufsize-bytes,outbuflen-bytes,outbufsize-bytes;recv-bytes,send-bytes;inbound-localhost-counters;outbound-localhost-counters;inbound-remote-counters;outbound-remote-counters|...where counters are: packets-total,bytes-total,packets-control,bytes-control-header,packets-control-retrans,bytes-control-header-retrans,packets-data,bytes-data-header,bytes-data-payload,packets-data-retrans,bytes-data-header-retrans,bytes-data-payload-retrans
</code></pre>
<p>Ram:</p>
<pre><code>[ram-header] interval-seconds,alloc-bytes,dealloc-bytes,total-bytes,pointers-count,failfree-count
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-shadow-log-messages"><a class="header" href="#parsing-shadow-log-messages">Parsing Shadow Log Messages</a></h1>
<p>Shadow logs simulator heartbeat messages that contain useful system information
for each virtual host in the experiment. For example, Shadow logs the number of
bytes sent/received, number of bytes allocated/deallocated, CPU usage, etc. You
can parse these heartbeat log messages to get insight into the simulation.
Details of these heartbeat messages can be found
<a href="log_format.html#heartbeat-messages">here</a>.</p>
<h2 id="example-simulation-data"><a class="header" href="#example-simulation-data">Example Simulation Data</a></h2>
<p>The methods we describe below can be used on the output from and Shadow
simulation. Here, we use the output from the <a href="getting_started_tgen.html">Traffic
Generation</a> example simulation for illustrative
purposes.</p>
<h2 id="parsing-and-plotting-results"><a class="header" href="#parsing-and-plotting-results">Parsing and Plotting Results</a></h2>
<p>Shadow includes some Python scripts that can parse important statistics from the
Shadow log messages, including network throughput over time, client download
statistics, and client load statistics, and then visualize the results. The
following will parse and plot the output produced from the above experiment:</p>
<pre><code class="language-bash"># parse the shadow output file
src/tools/parse-shadow.py --help
src/tools/parse-shadow.py --prefix results shadow.log
# plot the results
src/tools/plot-shadow.py --help
src/tools/plot-shadow.py --data results &quot;example-plots&quot;
</code></pre>
<p>The <code>parse-*.py</code> scripts generate <code>stats.*.json.xz</code> files. The (heavily trimmed)
contents of <code>stats.shadow.json</code> look like the following:</p>
<pre><code class="language-text">$ xzcat results/stats.shadow.json.xz
{
  &quot;nodes&quot;: {
    &quot;client:11.0.0.1&quot;: {
      &quot;recv&quot;: {
        &quot;bytes_control_header&quot;: {
          &quot;0&quot;: 0,
          &quot;1&quot;: 0,
          &quot;2&quot;: 0,
          ...
          &quot;599&quot;: 0
        },
        &quot;bytes_control_header_retrans&quot;: { ... },
        &quot;bytes_data_header&quot;: { ... },
        &quot;bytes_data_header_retrans&quot;: { ... },
        &quot;bytes_data_payload&quot;: { ... },
        &quot;bytes_data_payload_retrans&quot;: { ... },
        &quot;bytes_total&quot;: { ... }
      },
      &quot;send&quot;: { ... }
    },
    &quot;server:11.0.0.2&quot;: { ... }
  },
  &quot;ticks&quot;: {
    &quot;2&quot;: {
      &quot;maxrss_gib&quot;: 0.162216,
      &quot;time_seconds&quot;: 0.070114
    },
    &quot;3&quot;: { ... },
    ...
    &quot;599&quot;: { ... }
  }
}
</code></pre>
<p>The <code>plot-*.py</code> scripts generate graphs. Open the PDF file that was created to
see the graphed results.</p>
<h3 id="comparing-data-from-multiple-simulations"><a class="header" href="#comparing-data-from-multiple-simulations">Comparing Data from Multiple Simulations</a></h3>
<p>Consider a set of experiments where we would like to analyze the effect of
changing our hosts' socket receive buffer sizes. We run the following 2
experiments:</p>
<pre><code class="language-bash"># delete any existing simulation data and post-processing
rm -rf shadow.{data,log} 10KiB.{data,results,log} 100KiB.{data,results,log} *.results.pdf
shadow --socket-recv-buffer  10KiB --socket-recv-autotune false \
       --data-directory  10KiB.data shadow.yaml &gt;  10KiB.log
shadow --socket-recv-buffer 100KiB --socket-recv-autotune false \
       --data-directory 100KiB.data shadow.yaml &gt; 100KiB.log
</code></pre>
<p>To parse these log files, we use the following scripts:</p>
<pre><code class="language-bash">src/tools/parse-shadow.py --prefix=10KiB.results   10KiB.log
src/tools/parse-shadow.py --prefix=100KiB.results 100KiB.log
</code></pre>
<p>Each of the directories <code>10KiB.results/</code> and <code>100KiB.results/</code> now contain data
statistics files extracted from the log files. We can now combine and visualize
these results with the <code>plot-shadow.py</code> script:</p>
<pre><code class="language-bash">src/tools/plot-shadow.py --prefix &quot;recv-buffer&quot; --data 10KiB.results/ &quot;10 KiB&quot; --data 100KiB.results/ &quot;100 KiB&quot;
</code></pre>
<p>Open the PDF file that was created to compare results from the experiments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadow-configuration-overview"><a class="header" href="#shadow-configuration-overview">Shadow Configuration Overview</a></h1>
<p>Shadow requires a configuration file that provides a network graph and
information about the processes to run during the simulation. This configuration
file uses the YAML format. The options and their effect on the simulation are
described in more detail (alongside a simple example configuration file) on <a href="shadow_config_spec.html">the
configuration options page</a>.</p>
<p>Many of the configuration file options can also be overridden using command-line
options. For example, the configuration option
<a href="shadow_config_spec.html#generalstop_time"><code>general.stop_time</code></a> can be
overridden with shadow's <code>--stop-time</code> option, and
<a href="shadow_config_spec.html#generallog_level"><code>general.log_level</code></a> can be
overridden with <code>--log-level</code>. See <code>shadow --help</code> for other command-line
options.</p>
<h2 id="quantities-with-units"><a class="header" href="#quantities-with-units">Quantities with Units</a></h2>
<p>Some options such as
<a href="shadow_config_spec.html#hostshostnamebandwidth_down"><code>hosts.&lt;hostname&gt;.bandwidth_down</code></a>
accept quantity values containing a magnitude and a unit. For example bandwidth
values can be expressed as <code>1 Mbit</code>, <code>1000 Kbit</code>, <code>977 Kibit</code>, etc. The space
between the magnitude and unit is optional (for example <code>5Mbit</code>), and the unit
can be pluralized (for example <code>5 Mbits</code>). Units are case-sensitive.</p>
<h3 id="time"><a class="header" href="#time">Time</a></h3>
<p>Time values are expressed as either sub-second units, seconds, minutes, or
hours. Not all options will accept sub-second units. For example
<a href="shadow_config_spec.html#generalstop_time"><code>general.stop_time</code></a> must be
expressed in units of seconds or larger.</p>
<p>Acceptable units are:</p>
<ul>
<li>nanosecond / ns</li>
<li>microsecond / us / μs</li>
<li>millisecond / ms</li>
<li>second / sec / s</li>
<li>minute / min / m</li>
<li>hour / hr / h</li>
</ul>
<p>Examples: <code>30 s</code>, <code>2 hr</code>, <code>10 minutes</code>, <code>100 ms</code></p>
<h3 id="bandwidth"><a class="header" href="#bandwidth">Bandwidth</a></h3>
<p>Bandwidth values are expressed in bits-per-second with the unit <code>bit</code>. All
bandwidth values should be divisible by 8 bits-per-second (for example <code>30 bit</code>
is invalid, but <code>30 Kbit</code> is valid).</p>
<p>Acceptable unit <em>prefixes</em> are:</p>
<ul>
<li>kilo / K</li>
<li>kibi / Ki</li>
<li>mega / M</li>
<li>mebi / Mi</li>
<li>giga / G</li>
<li>gibi / Gi</li>
<li>tera / T</li>
<li>tebi / Ti</li>
</ul>
<p>Examples: <code>100 Mbit</code>, <code>100 Mbits</code>, <code>10 kilobits</code>, <code>128 bits</code></p>
<h3 id="byte-sizes"><a class="header" href="#byte-sizes">Byte Sizes</a></h3>
<p>Byte size values are expressed with the unit <code>byte</code> or <code>B</code>.</p>
<p>Acceptable unit <em>prefixes</em> are:</p>
<ul>
<li>kilo / K</li>
<li>kibi / Ki</li>
<li>mega / M</li>
<li>mebi / Mi</li>
<li>giga / G</li>
<li>gibi / Gi</li>
<li>tera / T</li>
<li>tebi / Ti</li>
</ul>
<p>Examples: <code>20 B</code>, <code>100 MB</code>, <code>100 megabyte</code>, <code>10 kibibytes</code>, <code>30 MiB</code>, <code>1024 Mbytes</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadow-configuration-specification"><a class="header" href="#shadow-configuration-specification">Shadow Configuration Specification</a></h1>
<p>Shadow uses the standard YAML format to accept configuration options from users.
The following describes Shadow's YAML format and all of the options that Shadow
supports that can be used to customize a simulation.</p>
<p>Example:</p>
<pre><code class="language-yaml">general:
  stop_time: 2 min
network:
  graph:
    type: 1_gbit_switch
hosts:
  server:
    processes:
    - path: /usr/sbin/nginx
      args: -c ../../../nginx.conf -p .
      start_time: 1
  client:
    quantity: 20
    processes:
    - path: /usr/bin/curl
      args: server --silent
      start_time: 5
</code></pre>
<h2 id="contents"><a class="header" href="#contents">Contents:</a></h2>
<ul>
<li><a href="shadow_config_spec.html#general"><code>general</code></a></li>
<li><a href="shadow_config_spec.html#generalbootstrap_end_time"><code>general.bootstrap_end_time</code></a></li>
<li><a href="shadow_config_spec.html#generaldata_directory"><code>general.data_directory</code></a></li>
<li><a href="shadow_config_spec.html#generalheartbeat_interval"><code>general.heartbeat_interval</code></a></li>
<li><a href="shadow_config_spec.html#generallog_level"><code>general.log_level</code></a></li>
<li><a href="shadow_config_spec.html#generalparallelism"><code>general.parallelism</code></a></li>
<li><a href="shadow_config_spec.html#generalseed"><code>general.seed</code></a></li>
<li><a href="shadow_config_spec.html#generalstop_time"><code>general.stop_time</code></a></li>
<li><a href="shadow_config_spec.html#generaltemplate_directory"><code>general.template_directory</code></a></li>
<li><a href="shadow_config_spec.html#network"><code>network</code></a></li>
<li><a href="shadow_config_spec.html#networkgraph"><code>network.graph</code></a></li>
<li><a href="shadow_config_spec.html#networkgraphtype"><code>network.graph.type</code></a></li>
<li><a href="shadow_config_spec.html#networkgraphpathinline"><code>network.graph.&lt;path|inline&gt;</code></a></li>
<li><a href="shadow_config_spec.html#networkuse_shortest_path"><code>network.use_shortest_path</code></a></li>
<li><a href="shadow_config_spec.html#experimental"><code>experimental</code></a></li>
<li><a href="shadow_config_spec.html#experimentalinterface_buffer"><code>experimental.interface_buffer</code></a></li>
<li><a href="shadow_config_spec.html#experimentalinterface_qdisc"><code>experimental.interface_qdisc</code></a></li>
<li><a href="shadow_config_spec.html#experimentalinterpose_method"><code>experimental.interpose_method</code></a></li>
<li><a href="shadow_config_spec.html#experimentalpreload_spin_max"><code>experimental.preload_spin_max</code></a></li>
<li><a href="shadow_config_spec.html#experimentalrunahead"><code>experimental.runahead</code></a></li>
<li><a href="shadow_config_spec.html#experimentalscheduler_policy"><code>experimental.scheduler_policy</code></a></li>
<li><a href="shadow_config_spec.html#experimentalsocket_recv_autotune"><code>experimental.socket_recv_autotune</code></a></li>
<li><a href="shadow_config_spec.html#experimentalsocket_recv_buffer"><code>experimental.socket_recv_buffer</code></a></li>
<li><a href="shadow_config_spec.html#experimentalsocket_send_autotune"><code>experimental.socket_send_autotune</code></a></li>
<li><a href="shadow_config_spec.html#experimentalsocket_send_buffer"><code>experimental.socket_send_buffer</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_cpu_pinning"><code>experimental.use_cpu_pinning</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_explicit_block_message"><code>experimental.use_explicit_block_message</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_legacy_working_dir"><code>experimental.use_legacy_working_dir</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_memory_manager"><code>experimental.use_memory_manager</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_o_n_waitpid_workarounds"><code>experimental.use_o_n_waitpid_workarounds</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_object_counters"><code>experimental.use_object_counters</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_openssl_rng_preload"><code>experimental.use_openssl_rng_preload</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_sched_fifo"><code>experimental.use_sched_fifo</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_shim_syscall_handler"><code>experimental.use_shim_syscall_handler</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_seccomp"><code>experimental.use_seccomp</code></a></li>
<li><a href="shadow_config_spec.html#experimentaluse_syscall_counters"><code>experimental.use_syscall_counters</code></a></li>
<li><a href="shadow_config_spec.html#experimentalworker_threads"><code>experimental.worker_threads</code></a></li>
<li><a href="shadow_config_spec.html#host_defaults"><code>host_defaults</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultscity_code_hint"><code>host_defaults.city_code_hint</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultscountry_code_hint"><code>host_defaults.country_code_hint</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultsheartbeat_interval"><code>host_defaults.heartbeat_interval</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultsheartbeat_log_info"><code>host_defaults.heartbeat_log_info</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultsheartbeat_log_level"><code>host_defaults.heartbeat_log_level</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultsip_address_hint"><code>host_defaults.ip_address_hint</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultslog_level"><code>host_defaults.log_level</code></a></li>
<li><a href="shadow_config_spec.html#host_defaultspcap_directory"><code>host_defaults.pcap_directory</code></a></li>
<li><a href="shadow_config_spec.html#hosts"><code>hosts</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnamebandwidth_down"><code>hosts.&lt;hostname&gt;.bandwidth_down</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnamebandwidth_up"><code>hosts.&lt;hostname&gt;.bandwidth_up</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameoptions"><code>hosts.&lt;hostname&gt;.options</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnamequantity"><code>hosts.&lt;hostname&gt;.quantity</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameprocesses"><code>hosts.&lt;hostname&gt;.processes</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameprocessesargs"><code>hosts.&lt;hostname&gt;.processes[*].args</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameprocessesenvironment"><code>hosts.&lt;hostname&gt;.processes[*].environment</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameprocessespath"><code>hosts.&lt;hostname&gt;.processes[*].path</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameprocessesquantity"><code>hosts.&lt;hostname&gt;.processes[*].quantity</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameprocessesstart_time"><code>hosts.&lt;hostname&gt;.processes[*].start_time</code></a></li>
<li><a href="shadow_config_spec.html#hostshostnameprocessesstop_time"><code>hosts.&lt;hostname&gt;.processes[*].stop_time</code></a></li>
</ul>
<h4 id="general"><a class="header" href="#general"><code>general</code></a></h4>
<p><em>Required</em></p>
<p>General experiment settings.</p>
<h4 id="generalbootstrap_end_time"><a class="header" href="#generalbootstrap_end_time"><code>general.bootstrap_end_time</code></a></h4>
<p>Default: &quot;0 sec&quot;<br />
Type: String OR Integer</p>
<p>The simulated time that ends Shadow's high network bandwidth/reliability
bootstrap period.</p>
<p>If the bootstrap end time is greater than 0, Shadow uses a simulation
bootstrapping period where hosts have unrestricted network bandwidth and no
packet drop. This can help to bootstrap large networks quickly when the network
hosts have low network bandwidth or low network reliability.</p>
<h4 id="generaldata_directory"><a class="header" href="#generaldata_directory"><code>general.data_directory</code></a></h4>
<p>Default: &quot;shadow.data&quot;<br />
Type: String</p>
<p>Path to store simulation output.</p>
<h4 id="generalheartbeat_interval"><a class="header" href="#generalheartbeat_interval"><code>general.heartbeat_interval</code></a></h4>
<p>Default: &quot;1 sec&quot;<br />
Type: String OR Integer</p>
<p>Interval at which to print heartbeat messages.</p>
<h4 id="generallog_level"><a class="header" href="#generallog_level"><code>general.log_level</code></a></h4>
<p>Default: &quot;info&quot;<br />
Type: &quot;error&quot; OR &quot;warning&quot; OR &quot;info&quot; OR &quot;debug&quot; OR &quot;trace&quot;</p>
<p>Log level of output written on stdout. If Shadow was built in release mode, then
messages at level 'trace' will always be dropped.</p>
<h4 id="generalparallelism"><a class="header" href="#generalparallelism"><code>general.parallelism</code></a></h4>
<p>Default: 1<br />
Type: Integer</p>
<p>How many parallel threads to use to run the simulation. Optimal performance is
usually obtained with <code>nproc</code>, or sometimes <code>nproc/2</code> with hyperthreading.</p>
<p>Virtual hosts depend on network packets that can potentially arrive from other
virtual hosts, so each worker can only advance according to the propagation
delay to avoid dependency violations. Therefore, not all threads will have 100%
CPU utilization.</p>
<h4 id="generalseed"><a class="header" href="#generalseed"><code>general.seed</code></a></h4>
<p>Default: 1<br />
Type: Integer</p>
<p>Initialize randomness using seed N.</p>
<h4 id="generalstop_time"><a class="header" href="#generalstop_time"><code>general.stop_time</code></a></h4>
<p><em>Required</em><br />
Type: String OR Integer</p>
<p>The simulated time at which simulated processes are sent a SIGKILL signal.</p>
<h4 id="generaltemplate_directory"><a class="header" href="#generaltemplate_directory"><code>general.template_directory</code></a></h4>
<p>Default: null<br />
Type: String OR null</p>
<p>Path to recursively copy during startup and use as the data-directory.</p>
<h4 id="network"><a class="header" href="#network"><code>network</code></a></h4>
<p><em>Required</em></p>
<p>Network settings.</p>
<h4 id="networkgraph"><a class="header" href="#networkgraph"><code>network.graph</code></a></h4>
<p><em>Required</em></p>
<p>The network topology graph.</p>
<p>A network topology represented by a connected graph with certain attributes
specified on the network nodes and edges. For more information on how to
structure this data, see the <a href="network_graph_overview.html">Network Graph Overview</a>.</p>
<p>Example:</p>
<pre><code class="language-yaml">network:
  graph:
    type: gml
    inline: |
      graph [
        ...
      ]
</code></pre>
<h4 id="networkgraphtype"><a class="header" href="#networkgraphtype"><code>network.graph.type</code></a></h4>
<p><em>Required</em><br />
Type: &quot;gml&quot; OR &quot;1_gbit_switch&quot;</p>
<p>The network graph can be specified in the GML format, or a built-in
&quot;1_gbit_switch&quot; graph with a single network node can be used instead.</p>
<p>The built-in &quot;1_gbit_switch&quot; graph contains the following:</p>
<pre><code class="language-text">graph [
  directed 0
  node [
    id 0
    ip_address &quot;0.0.0.0&quot;
    bandwidth_up &quot;1 Gbit&quot;
    bandwidth_down &quot;1 Gbit&quot;
  ]
  edge [
    source 0
    target 0
    latency &quot;1 ms&quot;
    packet_loss 0.0
  ]
]
</code></pre>
<h4 id="networkgraphpathinline"><a class="header" href="#networkgraphpathinline"><code>network.graph.&lt;path|inline&gt;</code></a></h4>
<p><em>Required if <code>network.graph.type</code> is &quot;gml&quot;</em><br />
Type: String</p>
<p>If the network graph type is not a built-in network graph, the graph data can be
specified as a path to an external file, or as an inline string.</p>
<p>If a path is given and begins with <code>~/</code>, it will be considered relative to the
current user's home directory.</p>
<h4 id="networkuse_shortest_path"><a class="header" href="#networkuse_shortest_path"><code>network.use_shortest_path</code></a></h4>
<p><em>Required</em><br />
Type: Bool</p>
<p>When routing packets, follow the shortest path rather than following a direct
edge between network nodes. If false, the network graph is required to be
complete.</p>
<h4 id="experimental"><a class="header" href="#experimental"><code>experimental</code></a></h4>
<p>Experimental experiment settings. Unstable and may change or be removed at any
time, regardless of Shadow version.</p>
<h4 id="experimentalinterface_buffer"><a class="header" href="#experimentalinterface_buffer"><code>experimental.interface_buffer</code></a></h4>
<p>Default: &quot;1024000 B&quot;<br />
Type: String OR Integer</p>
<p>Size of the interface receive buffer that accepts incoming packets.</p>
<h4 id="experimentalinterface_qdisc"><a class="header" href="#experimentalinterface_qdisc"><code>experimental.interface_qdisc</code></a></h4>
<p>Default: &quot;fifo&quot;<br />
Type: &quot;fifo&quot; OR &quot;roundrobin&quot;</p>
<p>The queueing discipline to use at the network interface.</p>
<h4 id="experimentalinterpose_method"><a class="header" href="#experimentalinterpose_method"><code>experimental.interpose_method</code></a></h4>
<p>Default: &quot;ptrace&quot;<br />
Type: &quot;ptrace&quot; OR &quot;preload&quot;</p>
<p>Which interposition method to use.</p>
<h4 id="experimentalpreload_spin_max"><a class="header" href="#experimentalpreload_spin_max"><code>experimental.preload_spin_max</code></a></h4>
<p>Default: 0<br />
Type: Integer</p>
<p>Max number of iterations to busy-wait on IPC semaphore before blocking.</p>
<h4 id="experimentalrunahead"><a class="header" href="#experimentalrunahead"><code>experimental.runahead</code></a></h4>
<p>Default: null<br />
Type: String OR null</p>
<p>If set, overrides the automatically calculated minimum time workers may run
ahead when sending events between virtual hosts.</p>
<h4 id="experimentalscheduler_policy"><a class="header" href="#experimentalscheduler_policy"><code>experimental.scheduler_policy</code></a></h4>
<p>Default: &quot;host&quot;<br />
Type: &quot;host&quot; OR &quot;steal&quot; OR &quot;thread&quot; OR &quot;threadxthread&quot; OR &quot;threadxhost&quot;</p>
<p>The event scheduler's policy for thread synchronization.</p>
<h4 id="experimentalsocket_recv_autotune"><a class="header" href="#experimentalsocket_recv_autotune"><code>experimental.socket_recv_autotune</code></a></h4>
<p>Default: true<br />
Type: Bool</p>
<p>Enable receive window autotuning.</p>
<h4 id="experimentalsocket_recv_buffer"><a class="header" href="#experimentalsocket_recv_buffer"><code>experimental.socket_recv_buffer</code></a></h4>
<p>Default: &quot;174760 B&quot;<br />
Type: String OR Integer</p>
<p>Initial size of the socket's receive buffer.</p>
<h4 id="experimentalsocket_send_autotune"><a class="header" href="#experimentalsocket_send_autotune"><code>experimental.socket_send_autotune</code></a></h4>
<p>Default: true<br />
Type: Bool</p>
<p>Enable send window autotuning.</p>
<h4 id="experimentalsocket_send_buffer"><a class="header" href="#experimentalsocket_send_buffer"><code>experimental.socket_send_buffer</code></a></h4>
<p>Default: &quot;131072 B&quot;<br />
Type: String OR Integer</p>
<p>Initial size of the socket's send buffer.</p>
<h4 id="experimentaluse_cpu_pinning"><a class="header" href="#experimentaluse_cpu_pinning"><code>experimental.use_cpu_pinning</code></a></h4>
<p>Default: true<br />
Type: Bool</p>
<p>Pin each thread and any processes it executes to the same logical CPU Core to
improve cache affinity.</p>
<h4 id="experimentaluse_explicit_block_message"><a class="header" href="#experimentaluse_explicit_block_message"><code>experimental.use_explicit_block_message</code></a></h4>
<p>Default: false<br />
Type: Bool</p>
<p>Send message to managed process telling it to stop spinning when a syscall
blocks.</p>
<h4 id="experimentaluse_legacy_working_dir"><a class="header" href="#experimentaluse_legacy_working_dir"><code>experimental.use_legacy_working_dir</code></a></h4>
<p>Default: false<br />
Type: Bool</p>
<p>Don't adjust the working directories of the virtual processes.</p>
<h4 id="experimentaluse_memory_manager"><a class="header" href="#experimentaluse_memory_manager"><code>experimental.use_memory_manager</code></a></h4>
<p>Default: true<br />
Type: Bool</p>
<p>Use the MemoryManager. It can be useful to disable for debugging, but will hurt
performance in most cases.</p>
<h4 id="experimentaluse_o_n_waitpid_workarounds"><a class="header" href="#experimentaluse_o_n_waitpid_workarounds"><code>experimental.use_o_n_waitpid_workarounds</code></a></h4>
<p>Default: false<br />
Type: Bool</p>
<p>Use performance workarounds for waitpid being O(n). Beneficial to disable if
waitpid is patched to be O(1), if using one logical processor per host, or in
some cases where it'd otherwise result in excessive detaching and reattaching.</p>
<h4 id="experimentaluse_object_counters"><a class="header" href="#experimentaluse_object_counters"><code>experimental.use_object_counters</code></a></h4>
<p>Default: true<br />
Type: Bool</p>
<p>Count object allocations and deallocations. If disabled, we will not be able to
detect object memory leaks.</p>
<h4 id="experimentaluse_openssl_rng_preload"><a class="header" href="#experimentaluse_openssl_rng_preload"><code>experimental.use_openssl_rng_preload</code></a></h4>
<p>Default: true<br />
Type: Bool</p>
<p>Preload our OpenSSL RNG library for all managed processes to mitigate
non-deterministic use of OpenSSL.</p>
<h4 id="experimentaluse_sched_fifo"><a class="header" href="#experimentaluse_sched_fifo"><code>experimental.use_sched_fifo</code></a></h4>
<p>Default: false<br />
Type: Bool</p>
<p>Use the SCHED_FIFO scheduler. Requires CAP_SYS_NICE. See sched(7),
capabilities(7).</p>
<h4 id="experimentaluse_shim_syscall_handler"><a class="header" href="#experimentaluse_shim_syscall_handler"><code>experimental.use_shim_syscall_handler</code></a></h4>
<p>Default: true<br />
Type: Bool</p>
<p>Use shim-side syscall handler to force hot-path syscalls to be handled via an
inter-process syscall with Shadow.</p>
<h4 id="experimentaluse_seccomp"><a class="header" href="#experimentaluse_seccomp"><code>experimental.use_seccomp</code></a></h4>
<p>Default: true iff experimental.interpose_method == preload.
Type: Bool</p>
<p>Use seccomp to trap syscalls.</p>
<h4 id="experimentaluse_syscall_counters"><a class="header" href="#experimentaluse_syscall_counters"><code>experimental.use_syscall_counters</code></a></h4>
<p>Default: false<br />
Type: Bool</p>
<p>Count the number of occurrences for individual syscalls.</p>
<h4 id="experimentalworker_threads"><a class="header" href="#experimentalworker_threads"><code>experimental.worker_threads</code></a></h4>
<p>Default: # of hosts in the simulation<br />
Type: Integer</p>
<p>Create N worker threads. Note though, that <code>general.parallelism</code> of them will be
allowed to run simultaneously. If unset, will create a thread for each simulated
Host. This is to work around limitations in ptrace, and may change in the
future.</p>
<h4 id="host_defaults"><a class="header" href="#host_defaults"><code>host_defaults</code></a></h4>
<p>Default options for all hosts. These options can also be overridden for each
host individually.</p>
<h4 id="host_defaultscity_code_hint"><a class="header" href="#host_defaultscity_code_hint"><code>host_defaults.city_code_hint</code></a></h4>
<p>Default: null<br />
Type: String OR null</p>
<p>City code hint for Shadow's name and routing system.</p>
<p>This hint will be used to assign the host to a network node based on the city
codes of nodes in the network graph.</p>
<h4 id="host_defaultscountry_code_hint"><a class="header" href="#host_defaultscountry_code_hint"><code>host_defaults.country_code_hint</code></a></h4>
<p>Default: null<br />
Type: String OR null</p>
<p>Country code hint for Shadow's name and routing system (ex: &quot;US&quot;).</p>
<p>This hint will be used to assign the host to a network node based on the country
codes of nodes in the network graph.</p>
<h4 id="host_defaultsheartbeat_interval"><a class="header" href="#host_defaultsheartbeat_interval"><code>host_defaults.heartbeat_interval</code></a></h4>
<p>Default: &quot;1 sec&quot;<br />
Type: String OR Integer</p>
<p>Amount of time between heartbeat messages for this host.</p>
<h4 id="host_defaultsheartbeat_log_info"><a class="header" href="#host_defaultsheartbeat_log_info"><code>host_defaults.heartbeat_log_info</code></a></h4>
<p>Default: [&quot;node&quot;]<br />
Type: Array of (&quot;node&quot; OR &quot;socket&quot; OR &quot;ram&quot;)</p>
<p>List of information to show in the host's heartbeat message.</p>
<h4 id="host_defaultsheartbeat_log_level"><a class="header" href="#host_defaultsheartbeat_log_level"><code>host_defaults.heartbeat_log_level</code></a></h4>
<p>Default: &quot;info&quot;<br />
Type: &quot;error&quot; OR &quot;warning&quot; OR &quot;info&quot; OR &quot;debug&quot; OR &quot;trace&quot;</p>
<p>Log level at which to print host statistics.</p>
<h4 id="host_defaultsip_address_hint"><a class="header" href="#host_defaultsip_address_hint"><code>host_defaults.ip_address_hint</code></a></h4>
<p>Default: null<br />
Type: String OR null</p>
<p>IPv4 address hint for Shadow's name and routing system (ex: &quot;100.0.0.1&quot;).</p>
<p>This hint will be used to assign the host to a network node based on the IP
values of nodes in the network graph.</p>
<h4 id="host_defaultslog_level"><a class="header" href="#host_defaultslog_level"><code>host_defaults.log_level</code></a></h4>
<p>Default: null<br />
Type: &quot;error&quot; OR &quot;warning&quot; OR &quot;info&quot; OR &quot;debug&quot; OR &quot;trace&quot; OR null</p>
<p>Log level at which to print host log messages.</p>
<h4 id="host_defaultspcap_directory"><a class="header" href="#host_defaultspcap_directory"><code>host_defaults.pcap_directory</code></a></h4>
<p>Default: null<br />
Type: String OR null</p>
<p>Where to save the pcap files (relative to the host directory).</p>
<p>Logs all network input and output for this host in PCAP format (for viewing in
e.g. wireshark).</p>
<h4 id="hosts"><a class="header" href="#hosts"><code>hosts</code></a></h4>
<p><em>Required</em><br />
Type: Object</p>
<p>The simulated hosts which execute processes. Each field corresponds to a host
configuration, with the field name being used as the network hostname.</p>
<p>Shadow assigns each host to a network node in the <a href="network_graph_overview.html">network graph</a>.</p>
<h4 id="hostshostnamebandwidth_down"><a class="header" href="#hostshostnamebandwidth_down"><code>hosts.&lt;hostname&gt;.bandwidth_down</code></a></h4>
<p>Default: null<br />
Type: String OR Integer OR null</p>
<p>Downstream bandwidth capacity of the host.</p>
<p>Overrides any default bandwidth values set in the assigned network graph
node.</p>
<h4 id="hostshostnamebandwidth_up"><a class="header" href="#hostshostnamebandwidth_up"><code>hosts.&lt;hostname&gt;.bandwidth_up</code></a></h4>
<p>Default: null<br />
Type: String OR Integer OR null</p>
<p>Upstream bandwidth capacity of the host.</p>
<p>Overrides any default bandwidth values set in the assigned network graph
node.</p>
<h4 id="hostshostnameoptions"><a class="header" href="#hostshostnameoptions"><code>hosts.&lt;hostname&gt;.options</code></a></h4>
<p>See <a href="shadow_config_spec.html#host_defaults"><code>host_defaults</code></a>.</p>
<h4 id="hostshostnamequantity"><a class="header" href="#hostshostnamequantity"><code>hosts.&lt;hostname&gt;.quantity</code></a></h4>
<p>Default: 1<br />
Type: Integer</p>
<p>Number of hosts to start.</p>
<p>If quantity is greater than 1, each host's hostname will be suffixed with a
counter. For example, a host with an id of <code>host</code> and quantity of 2 would
produce hosts with hostnames <code>host1</code> and <code>host2</code>.</p>
<h4 id="hostshostnameprocesses"><a class="header" href="#hostshostnameprocesses"><code>hosts.&lt;hostname&gt;.processes</code></a></h4>
<p><em>Required</em><br />
Type: Array</p>
<p>Virtual software processes that the host will run.</p>
<h4 id="hostshostnameprocessesargs"><a class="header" href="#hostshostnameprocessesargs"><code>hosts.&lt;hostname&gt;.processes[*].args</code></a></h4>
<p>Default: &quot;&quot;<br />
Type: String OR Array of String</p>
<p>Process arguments.</p>
<h4 id="hostshostnameprocessesenvironment"><a class="header" href="#hostshostnameprocessesenvironment"><code>hosts.&lt;hostname&gt;.processes[*].environment</code></a></h4>
<p>Default: &quot;&quot;<br />
Type: String</p>
<p>Environment variables passed when executing this process. Multiple variables can
be specified by using a semicolon separator (ex: <code>ENV_A=1;ENV_B=2</code>).</p>
<h4 id="hostshostnameprocessespath"><a class="header" href="#hostshostnameprocessespath"><code>hosts.&lt;hostname&gt;.processes[*].path</code></a></h4>
<p><em>Required</em><br />
Type: String</p>
<p>If the path begins with <code>~/</code>, it will be considered relative to the current
user's home directory.</p>
<h4 id="hostshostnameprocessesquantity"><a class="header" href="#hostshostnameprocessesquantity"><code>hosts.&lt;hostname&gt;.processes[*].quantity</code></a></h4>
<p>Default: 1<br />
Type: Integer</p>
<p>The number of replicas of this process to execute.</p>
<h4 id="hostshostnameprocessesstart_time"><a class="header" href="#hostshostnameprocessesstart_time"><code>hosts.&lt;hostname&gt;.processes[*].start_time</code></a></h4>
<p>Default: &quot;0 sec&quot;<br />
Type: String OR Integer</p>
<p>The simulated time at which to execute the process.</p>
<h4 id="hostshostnameprocessesstop_time"><a class="header" href="#hostshostnameprocessesstop_time"><code>hosts.&lt;hostname&gt;.processes[*].stop_time</code></a></h4>
<p>Default: null<br />
Type: String OR Integer OR null</p>
<p>The simulated time at which to send a SIGKILL signal to the process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-graph-overview"><a class="header" href="#network-graph-overview">Network Graph Overview</a></h1>
<p>Processes running in Shadow do not have access to the internet; instead,
processes running on Shadow virtual hosts utilize an internal routing module to
communicate with other processes running on other virtual hosts in the
simulation. The routing module is used to position virtual hosts within a
network topology, to compute communication paths between virtual hosts, and to
enforce network path characteristics like latency and packet loss.</p>
<p>Importantly, the routing module is currently used to <em>model</em> the performance
characteristics of internet paths; we do not <em>simulate</em> the behavior of network
routers (we do not run routing protocols like
<a href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol">BGP</a>).</p>
<p>This page describes the routing module and how it can be configured.</p>
<h2 id="graph"><a class="header" href="#graph">Graph</a></h2>
<p>Shadow represents a network topology over which processes can communicate using
a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">weighted graph</a>.
The graph contains <em>vertices</em> that abstractly represent network locations, and
<em>edges</em> representing network paths between those locations.</p>
<p>When referring to a network graph, the terms <em>vertices</em> and <em>nodes</em> are
interchangeable. In our documentation, we refer to these as <em>nodes</em>. Note that
nodes in the network graph are distinct from virtual hosts in the Shadow config
file: a virtual host models an end-host machine, whereas a network node
represents a location at which a host can connect to the simulated network.</p>
<p>Shadow requires that the network graph is
<a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">connected</a> such that
there exists at least one <em>path</em> (a series of one or more edges) between every
pair of nodes.</p>
<h2 id="behavior"><a class="header" href="#behavior">Behavior</a></h2>
<p>The graph encodes network positioning and path characteristics as attributes on
the nodes and edges. Shadow uses the connectivity graph along with the
information encoded in node and edge attributes to:</p>
<ul>
<li>attach virtual hosts to specific nodes (i.e., locations) in the network
graph;</li>
<li>assign the bandwidth allowed for each attached virtual host;</li>
<li>compute the shortest path (weighted by edge <code>latency</code>) between two virtual
hosts using <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's
algorithm</a>; and</li>
<li>compute the end-to-end latency and packet loss for the shortest path.</li>
</ul>
<p>The bandwidth of the virtual hosts and the end-to-end latency and packet loss
for a shortest path between two virtual hosts are then enforced for all network
communication.</p>
<h2 id="important-notes"><a class="header" href="#important-notes">Important Notes</a></h2>
<ul>
<li>The network graph may be directed or undirected, as long as the graph is
structured such that every node can reach every other node through a
series of edges.</li>
<li>If the network graph is a <a href="https://en.wikipedia.org/wiki/Complete_graph">complete
graph</a> (there exists a single
unique edge between every pair of nodes), then we can avoid running the
shortest path algorithm as a performance optimization by setting the
<a href="shadow_config_spec.html#networkuse_shortest_path">use_shortest_path
option</a> to <code>False</code>.</li>
</ul>
<h2 id="network-graph-attributes"><a class="header" href="#network-graph-attributes">Network Graph Attributes</a></h2>
<p>We encode attributes on the nodes and edges that allow for configuring the
simulated network characteristics. The attributes and their effect on the
simulated network are described in more detail (alongside a simple example
graph) on <a href="network_graph_spec.html">the network graph specification page</a>.</p>
<h2 id="using-an-existing-graph"><a class="header" href="#using-an-existing-graph">Using an Existing Graph</a></h2>
<p>We created a large network graph representing worldwide latencies and bandwidths
as of 2018 using the <a href="https://atlas.ripe.net">RIPE Atlas measurement platform</a>.
The graph contains network bandwidths and latencies in and between major cities
around the world, and is suitable for general usage for most types of Shadow
simualtions. The graph is <a href="https://tmodel-ccs2018.github.io/data/shadow/network/atlas-lossless.201801.shadow113.graphml.xml.xz">available for download as a research
artifact</a>
and more details about the measurement methodology is available on <a href="https://tmodel-ccs2018.github.io">the research
artifacts site</a>.</p>
<p>Note: <a href="http://github.com/shadow/atlas">the scripts we used to create the graph</a>
are also available, but are not recommended for general use. The scripts require
advanced knowledge of RIPE Atlas and also require that you possess RIPE Atlas
credits to conduct the measurements needed to create a new graph. We recommend
using our existing graph linked above instead, which we may periodically update.</p>
<h2 id="creating-your-own-graph"><a class="header" href="#creating-your-own-graph">Creating Your Own Graph</a></h2>
<p>The python module <a href="http://networkx.github.io/">networkx</a> can be used to create
and manipulate more complicated graphs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-graph-specification"><a class="header" href="#network-graph-specification">Network Graph Specification</a></h1>
<p>The <a href="network_graph_overview.html">network graph overview</a> provides a general
summary of Shadow's use of a network graph to abstractly model network position
and to connect virtual hosts in a network topology while enforcing network
characteristics on paths between hosts. This page describes the specific
attributes that can be configured in the network graph, and the effect that each
attribute has on the simulation.</p>
<h3 id="example-graph"><a class="header" href="#example-graph">Example Graph</a></h3>
<p>Below is an example of a simple network graph in the Shadow-supported GML format
(note that GML calls graph <em>vertices</em> as <em>nodes</em>, but these terms are generally
interchangeable).</p>
<pre><code class="language-gml">graph [
  directed 0
  node [
    id 0
    label &quot;node at 1.2.3.4&quot;
    country_code &quot;US&quot;
    city_code &quot;Portland&quot;
    ip_address &quot;1.2.3.4&quot;
    bandwidth_down &quot;100 Mbit&quot;
    bandwidth_up &quot;100 Mbit&quot;
  ]
  edge [
    source 0
    target 0
    label &quot;path from 1.2.3.4 to 1.2.3.4&quot;
    latency &quot;10 ms&quot;
    jitter &quot;0 ms&quot;
    packet_loss 0.0
  ]
]
</code></pre>
<h3 id="configurable-attributes"><a class="header" href="#configurable-attributes">Configurable Attributes</a></h3>
<ul>
<li><a href="network_graph_spec.html#graphdirected"><code>graph.directed</code></a></li>
<li><a href="network_graph_spec.html#nodeid"><code>node.id</code></a></li>
<li><a href="network_graph_spec.html#nodelabel"><code>node.label</code></a></li>
<li><a href="network_graph_spec.html#nodecountry_code"><code>node.country_code</code></a></li>
<li><a href="network_graph_spec.html#nodecity_code"><code>node.city_code</code></a></li>
<li><a href="network_graph_spec.html#nodeip_address"><code>node.ip_address</code></a></li>
<li><a href="network_graph_spec.html#nodebandwidth_down"><code>node.bandwidth_down</code></a></li>
<li><a href="network_graph_spec.html#nodebandwidth_up"><code>node.bandwidth_up</code></a></li>
<li><a href="network_graph_spec.html#edgesource"><code>edge.source</code></a></li>
<li><a href="network_graph_spec.html#edgetarget"><code>edge.target</code></a></li>
<li><a href="network_graph_spec.html#edgelabel"><code>edge.label</code></a></li>
<li><a href="network_graph_spec.html#edgelatency"><code>edge.latency</code></a></li>
<li><a href="network_graph_spec.html#edgejitter"><code>edge.jitter</code></a></li>
<li><a href="network_graph_spec.html#edgepacket_loss"><code>edge.packet_loss</code></a></li>
</ul>
<h4 id="graphdirected"><a class="header" href="#graphdirected"><code>graph.directed</code></a></h4>
<p>Required: False<br />
Default: <code>0</code><br />
Type: Integer</p>
<p>Specifies the symmetry of the edges in the graph. If set to <code>0</code> (the default),
the graph is an <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">undirected
graph</a>: an edge
between node <code>u</code> and node <code>v</code> is symmetric and can be used to construct a
path both from <code>u</code> to <code>v</code> and from <code>v</code> to <code>u</code>. If set to <code>1</code>, the graph is a
<a href="https://en.wikipedia.org/wiki/Directed_graph">directed graph</a>: an edge from
node <code>u</code> to node <code>v</code> is assymmetric and can only be used to construct a path
from <code>u</code> to <code>v</code> (a separate edge from <code>v</code> to <code>u</code> must be specified to compose a
path in the reverse direction).</p>
<h4 id="nodeid"><a class="header" href="#nodeid"><code>node.id</code></a></h4>
<p>Required: True<br />
Type: Integer</p>
<p>A unique integer identifier for a given node.</p>
<h4 id="nodelabel"><a class="header" href="#nodelabel"><code>node.label</code></a></h4>
<p>Required: False<br />
Default: n/a<br />
Type: String</p>
<p>An optional, human-meaningful string description of the node. The string may
be used in log messages printed by Shadow.</p>
<h4 id="nodecountry_code"><a class="header" href="#nodecountry_code"><code>node.country_code</code></a></h4>
<p>Required: False<br />
Default: n/a<br />
Type: String</p>
<p>A code for the country in which the node represented by this node is located.
This code can be used to control the placement of hosts in the network: when
attaching a specific host into the network, we ignore any node whose
<code>country_code</code> does not match the host's <a href="shadow_config_spec.html#host_defaultscountry_code_hint"><code>country_code_hint</code> host configuration
value</a> (if one is
configured).</p>
<h4 id="nodecity_code"><a class="header" href="#nodecity_code"><code>node.city_code</code></a></h4>
<p>Required: False<br />
Default: n/a<br />
Type: String</p>
<p>A code for the city in which the node represented by this node is located.
This code can be used to control the placement of hosts in the network: when
attaching a specific host into the network, we ignore any node whose
<code>city_code</code> does not match the host's <a href="shadow_config_spec.html#host_defaultscity_code_hint"><code>city_code_hint</code> host configuration
value</a> (if one is
configured).</p>
<h4 id="nodeip_address"><a class="header" href="#nodeip_address"><code>node.ip_address</code></a></h4>
<p>Required: False<br />
Default: n/a
Type: String</p>
<p>An IP address at which the node represented by this node is located. This
address can be used to control the placement of hosts in the network: after
filtering nodes based on the city and country codes (as described above), we
perform a <a href="https://en.wikipedia.org/wiki/Longest_prefix_match">longest prefix
match</a> on the remaining
nodes by comparing the node <code>ip_address</code> with the host's <a href="shadow_config_spec.html#host_defaultsip_address_hint"><code>ip_address_hint</code>
host configuration value</a>
(if one is configured) and attach the host to the node with the closest match.
We assign the host the address specified in <code>ip_address_hint</code> as long as that
address has not yet been assigned to another host, otherwise we choose a unique
address nearby to the requested address.</p>
<h4 id="nodebandwidth_down"><a class="header" href="#nodebandwidth_down"><code>node.bandwidth_down</code></a></h4>
<p>Required: True<br />
Type: String</p>
<p>A string defining the downstream (receive) bandwidth that will be allowed for
any host attached to this node. Hosts may individually override this value in
<a href="shadow_config_spec.html#hostshostnamebandwidth_down">the Shadow config file</a>.
The format of the string specifies the bandwidth and its unit as described in
the <a href="shadow_config_spec.html">config documentation</a>, e.g., <code>10 Mbit</code>. Note that
this bandwidth is allowed for every host that is attached to this node; it is
<strong>not</strong> the total bandwidth logically available at the node (which is not
defined).</p>
<h4 id="nodebandwidth_up"><a class="header" href="#nodebandwidth_up"><code>node.bandwidth_up</code></a></h4>
<p>Required: True<br />
Type: String</p>
<p>A string defining the upstream (send) bandwidth that will be allowed for any
host attached to this node. Hosts may individually override this value in <a href="shadow_config_spec.html#hostshostnamebandwidth_up">the
Shadow config file</a>. The
format of the string specifies the bandwidth and its unit as described in the
<a href="shadow_config_spec.html">config documentation</a>, e.g., <code>10 Mbit</code>. Note that
this bandwidth is allowed for every host that is attached to this node; it is
<strong>not</strong> the total bandwidth logically available at the node (which is not
defined).</p>
<h4 id="edgesource"><a class="header" href="#edgesource"><code>edge.source</code></a></h4>
<p>Required: True<br />
Type: Integer</p>
<p>The unique integer identifier of the first of two nodes of the edge. The
node must exist in the graph. If the graph is directed, this node is treated
as the source or start of the edge.</p>
<h4 id="edgetarget"><a class="header" href="#edgetarget"><code>edge.target</code></a></h4>
<p>Required: True<br />
Type: Integer</p>
<p>The unique integer identifier of the second of two nodes of the edge. The
node must exist in the graph. If the graph is directed, this node is treated
as the target or end of the edge.</p>
<h4 id="edgelabel"><a class="header" href="#edgelabel"><code>edge.label</code></a></h4>
<p>Required: False<br />
Default: n/a<br />
Type: String</p>
<p>An optional, human-meaningful string description of the edge. The string may be
used in log messages printed by Shadow.</p>
<h4 id="edgelatency"><a class="header" href="#edgelatency"><code>edge.latency</code></a></h4>
<p>Required: True<br />
Type: String</p>
<p>The latency that will be added to packets traversing this edge. This value is
used as a weight while running Dijkstra's shortest path algorithm. The format of
the string specifies the latency and its unit, e.g., <code>10 ms</code>. If a unit is not
specified, it will be assumed that it is in the base unit of &quot;seconds&quot;.</p>
<h4 id="edgejitter"><a class="header" href="#edgejitter"><code>edge.jitter</code></a></h4>
<p>Required: False<br />
Default: n/a<br />
Type: String</p>
<p>This keyword is allowed but currently nonfunctional; it is reserved for future
use.</p>
<h4 id="edgepacket_loss"><a class="header" href="#edgepacket_loss"><code>edge.packet_loss</code></a></h4>
<p>Required: True<br />
Type: Float</p>
<p>A fractional value between 0 and 1 representing the chance that a packet
traversing this edge will get dropped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-simulations-from-shadow-1x"><a class="header" href="#migrating-simulations-from-shadow-1x">Migrating Simulations from Shadow 1.x</a></h1>
<p>Shadow 2.0 has changed the formatting of its configuration and network graph files.
The configuration format has changed from XML to YAML, and the network graph format
has changed from GraphML to GML. Various options have been added, renamed, and
removed. Shadow includes convenience scripts to convert these files to their new
formats. These scripts are intended to aid in converting to the new formats, and
you should manually compare the original file to the new converted file to make
sure it includes all of the options you expect.</p>
<p>When encountering a tag/attribute that is not supported by the new format, these
scripts will either:</p>
<ol>
<li>Copy it to the new file anyways. When attempting to use this new file with
Shadow, Shadow will raise an error for this unexpected field.</li>
<li>Ignore it and output a warning.</li>
</ol>
<h2 id="converting-a-configuration-file-to-the-shadow-20-format"><a class="header" href="#converting-a-configuration-file-to-the-shadow-20-format">Converting a configuration file to the Shadow 2.0 format</a></h2>
<p>The following will create a new configuration file <code>my-shadow-config.yaml</code>.</p>
<pre><code class="language-bash">shadow/src/tools/convert_legacy_config.py my-shadow-config.xml
</code></pre>
<p>You may have to manually tweak the new configuration file to support the new
virtual process <a href="https://en.wikipedia.org/wiki/Working_directory">working
directory</a>. In Shadow 1.x, each
virtual process (then called a plugin) has the same working directory as the
Shadow process itself. In Shadow 2.x, the working directory of each virtual
process is its host data directory. For example a process running on host
<code>myhost</code> would have the working directory <code>shadow.data/hosts/myhost/</code>. You can
use the
<a href="shadow_config_spec.html#experimentaluse_legacy_working_dir"><code>experimental.use_legacy_working_dir</code></a>
option to use the Shadow 1.x working directory, but this is an experimental
option and may be removed in the future.</p>
<h2 id="converting-a-network-graph-file-to-the-shadow-20-format"><a class="header" href="#converting-a-network-graph-file-to-the-shadow-20-format">Converting a network graph file to the Shadow 2.0 format</a></h2>
<p>The following will create a new network graph file <code>my-shadow-topology.gml</code>.</p>
<pre><code class="language-bash">shadow/src/tools/convert_legacy_topology.py my-shadow-topology.graphml.xml &gt; my-shadow-topology.gml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disabling-sidechannel-mitigations"><a class="header" href="#disabling-sidechannel-mitigations">Disabling Sidechannel Mitigations</a></h1>
<p>Sidechannel attacks in the style of
<a href="https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)">Spectre</a> and
<a href="https://en.wikipedia.org/wiki/Meltdown_(security_vulnerability)">Meltdown</a>
allow malicious code to access data it otherwise wouldn't be able to. Modern
systems employ countermeasures to prevent these attacks, which typically incur
some performance cost, and may not be necessary when running Shadow simulations.
i.e. Shadow's performance can be improved by disabling these mitigations.</p>
<p>Keep in mind that Shadow already isn't designed to protect itself or its host
system from malicious software. See <a href="security.html">Security</a>.</p>
<h2 id="speculative-store-bypass"><a class="header" href="#speculative-store-bypass">Speculative Store Bypass</a></h2>
<p>The Speculative Store Bypass attack allows malicious code to read data it
otherwise wouldn't be able to, e.g. due to software sandboxing such as in a
javascript engine.  For a high-level overview of this attack and mitigations,
see:
https://www.redhat.com/en/blog/speculative-store-bypass-explained-what-it-how-it-works.
For a more technical overview, see 
https://software.intel.com/content/dam/develop/external/us/en/documents/336996-speculative-execution-side-channel-mitigations.pdf.</p>
<p>We have observed the mitigation for this vulnerability to add roughly a <a href="https://github.com/shadow/shadow/issues/1489#issuecomment-871445482">30%
performance overhead</a> to Shadow simulations. Because process isolation is
already sufficient to mitigate this vulnerability (See <a href="https://software.intel.com/content/dam/develop/external/us/en/documents/336996-speculative-execution-side-channel-mitigations.pdf">&quot;Process
Isolation&quot;</a>),
and because Shadow already makes <a href="security.html">no attempt</a> to protect itself
from malicious code within its own processes, and isn't designed to run in a
managed-code environment itself, enabling this mitigation in Shadow and its
managed processes doesn't have any clear benefit.</p>
<p>Shadow itself makes use of <code>seccomp</code>, but uses the
<code>SECCOMP_FILTER_FLAG_SPEC_ALLOW</code> flag to avoid turning on this mitigation.  It
also logs a warning if it detects this mitigation is already enabled.</p>
<p>One common way this mitigation can be turned on inadvertently is by running
inside a Docker container, with seccomp enabled (which is the default).  You can
avoid this by turning off seccomp entirely (using <a href="https://docs.docker.com/engine/security/seccomp/#run-without-the-default-seccomp-profile"><code>--security-opt seccomp=unconfined</code></a>, but this might not be an option when running in a
shared environment. Unfortunately, Docker currently <a href="https://github.com/moby/moby/issues/42619">doesn't
expose</a> an option to use its seccomp
functionality without turning on this mitigation. </p>
<p>Another way to avoid enabling this mitigation is by changing the <a href="https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html">kernel
parameter</a>
<code>spec_store_bypass_disable</code>. Overriding its default value of <code>seccomp</code> to
<code>prctl</code> will still allow software sandboxes such as javascript engines to enable
this mitigation, but will no longer enable it by default when installing a
<code>seccomp</code> filter. In principle this could create a vulnerability if there's code
running on the system that relies on the default behavior without explicitly
opting in via <code>prctl</code>, so use some caution. For more discussion on this
parameter, see this discussion on the kernel mailing list about whether the
kernel default ought to be changed from <code>seccomp</code> to <code>prctl</code>:
https://lore.kernel.org/lkml/20201104215702.GG24993@redhat.com/</p>
<h2 id="other-mitigations"><a class="header" href="#other-mitigations">Other mitigations</a></h2>
<p>In some ad-hoc measurements we've found that disabling <em>all</em> sidechannel
mitigations with
<a href="https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html"><code>mitigations=off</code></a>
also provides a significant performance boost. We haven't thoroughly evaluated
the exact benefits though, and this setting could expose your system to attack.
At a minimum, this isn't advised on a system that runs <em>any</em> untrusted code at
<em>any</em> privilege level, including in managed environments such as running
javascript in a web browser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallel-simulations"><a class="header" href="#parallel-simulations">Parallel simulations</a></h1>
<p>Some care must be taken when running multiple Shadow simulations on the same
hardware at the same time. By default, Shadow pins threads to specific CPUs to
avoid CPU migrations. The CPU selection logic isn't aware of other processes
that may be using substantial CPU time and/or pinning, <em>including other Shadow
simulations</em>. i.e. without some care, multiple Shadow simulations running on the
same machine at the same time will generally end up trying to use the same set
of CPUs, even if other CPUs on the machine are idle.</p>
<h2 id="disabling-pinning"><a class="header" href="#disabling-pinning">Disabling pinning</a></h2>
<p>The simplest solution is to disable CPU pinning entirely. This has a substantial
performance penalty (with some reports as high as 3x), but can be a reasonable
solution for small simulations. Pinning can be disabled by passing
<code>--use-cpu-pinning=false</code> to Shadow.</p>
<h2 id="setting-an-initial-cpu-affinity"><a class="header" href="#setting-an-initial-cpu-affinity">Setting an initial CPU affinity</a></h2>
<p>Shadow checks the initial CPU affinity assigned to it, and only assigns to CPUs
within that set. The easiest way to run Shadow with a subset of CPUs is with the
<code>taskset</code> utility. e.g. to start one Shadow simulation using CPUs 0-9 and
another using CPUs 10-19, you could use:</p>
<pre><code>$ (cd sim1 &amp;&amp; taskset --cpu-list 0-9 shadow sim1config.yml) &amp;
$ (cd sim2 &amp;&amp; taskset --cpu-list 10-19 shadow sim2config.yml) &amp;
</code></pre>
<p>Shadow similarly avoids trying to pin to CPUs outside of its cgroup cpuset (see
cpuset(7)). This allows Shadow to work correctly in such scenarios (such as
running in a container on a shared machine that only has access to some CPUs),
but is generally more complex and requires higher privilege than setting the CPU
affinity with <code>taskset</code>.</p>
<h2 id="choosing-a-cpu-set"><a class="header" href="#choosing-a-cpu-set">Choosing a CPU set</a></h2>
<p>When assigning Shadow a subset of CPUs, some care must be taken to get optimal
performance. You can use the <code>lscpu</code> utility to see the layout of the CPUs on
your machine.</p>
<ul>
<li>Avoid using multiple CPUs on the same core (aka hyperthreading). Such CPUs
compete with each-other for resources.</li>
<li>Prefer CPUs on the same socket and (NUMA) node. Such CPUs share cache, which
is typically beneficial in Shadow simulations.</li>
</ul>
<p>For example, given the <code>lscpu</code> output:</p>
<pre><code>$ lscpu --parse=cpu,core,socket,node
# The following is the parsable format, which can be fed to other
# programs. Each different item in every column has an unique ID
# starting from zero.
# CPU,Core,Socket,Node
0,0,0,0
1,1,1,1
2,2,0,0
3,3,1,1
4,4,0,0
5,5,1,1
6,6,0,0
7,7,1,1
8,8,0,0
9,9,1,1
10,10,0,0
11,11,1,1
12,12,0,0
13,13,1,1
14,14,0,0
15,15,1,1
16,16,0,0
17,17,1,1
18,18,0,0
19,19,1,1
20,20,0,0
21,21,1,1
22,22,0,0
23,23,1,1
24,24,0,0
25,25,1,1
26,26,0,0
27,27,1,1
28,28,0,0
29,29,1,1
30,30,0,0
31,31,1,1
32,32,0,0
33,33,1,1
34,34,0,0
35,35,1,1
36,36,0,0
37,37,1,1
38,38,0,0
39,39,1,1
40,0,0,0
41,1,1,1
42,2,0,0
43,3,1,1
44,4,0,0
45,5,1,1
46,6,0,0
47,7,1,1
48,8,0,0
49,9,1,1
50,10,0,0
51,11,1,1
52,12,0,0
53,13,1,1
54,14,0,0
55,15,1,1
56,16,0,0
57,17,1,1
58,18,0,0
59,19,1,1
60,20,0,0
61,21,1,1
62,22,0,0
63,23,1,1
64,24,0,0
65,25,1,1
66,26,0,0
67,27,1,1
68,28,0,0
69,29,1,1
70,30,0,0
71,31,1,1
72,32,0,0
73,33,1,1
74,34,0,0
75,35,1,1
76,36,0,0
77,37,1,1
78,38,0,0
79,39,1,1
</code></pre>
<p>A reasonable configuration for two simulations might be <code>taskset --cpu-list 0-39:2</code> (CPUs 0,2,...,38) and <code>taskset --cpu-list 1-39:2</code>. (CPUs 1,3,...,39).
This assignment leaves CPUs 40-79 idle, since those share the same physical
cores at CPUs 0-39, puts the first simulation on socket 0 and numa node 0, and
the second simulation on socket 1 and numa node 1.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-and-profiling"><a class="header" href="#debugging-and-profiling">Debugging and profiling</a></h1>
<h2 id="building-the-c-rust-bindings"><a class="header" href="#building-the-c-rust-bindings">Building the C-Rust bindings</a></h2>
<p>When required, you can rebuild all of the C-Rust bindings by running:</p>
<pre><code class="language-bash">cd build &amp;&amp; cmake --target bindings .. &amp;&amp; make bindings
</code></pre>
<p>To see the specific options/flags provided to bindgen and cbindgen, you can use
<code>make VERBOSE=1 bindings</code>.</p>
<p>Since the C bindings and Rust bindings rely on each other, you may sometimes
need to build the bindings in a specific order. Instead of <code>make bindings</code>, you
can be more specific using for example <code>make bindings_main_rust</code> to make the
Rust bindings for <code>src/main</code>.</p>
<p>You may need to install bindgen, cbindgen, and clang:</p>
<pre><code class="language-bash">apt install -y clang
cargo install --force --version 0.18.0 cbindgen
cargo install --force --version 0.57.0 bindgen
</code></pre>
<p>The versions of bindgen and cbindgen you install should match the <a href="https://github.com/shadow/shadow/blob/main/.github/workflows/lint.yml">versions
installed in the
CI</a>.</p>
<h2 id="extra-tests"><a class="header" href="#extra-tests">Extra tests</a></h2>
<p>Shadow includes tests that require additional dependencies, such as Tor, TGen,
and networkx. These aren't run by default, but are run as part of the CI tests.
To run them locally, first make sure that both tor and tgen are located at
<code>~/.local/bin/{tor,tgen}</code>. These can be symlinks to tor and tgen binaries
elsewhere in the filesystem. You should also install all of Shadow's optional
dependencies.</p>
<p>It is recommended to build Shadow in release mode, otherwise the Tor tests may
not complete before the timeout.</p>
<pre><code class="language-bash">./setup test -- --build-config extra
# To exclude the Tor tests (for example if you built Shadow in debug mode)
./setup test -- --build-config extra --label-exclude tor
</code></pre>
<p>If you change the version of tor located at <code>~/.local/bin/tor</code>, make sure to
re-run <code>./setup build --test</code>.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="debugging-shadow-using-gdb"><a class="header" href="#debugging-shadow-using-gdb">Debugging Shadow using GDB</a></h3>
<p>Shadow is currently built with debugging symbols in both debug and release
builds, though it may be easier to debug a debug build (generated by passing the
<code>--debug</code> flag to <code>setup build</code>).</p>
<p>Shadow can be run under <code>gdb</code> by prepending <code>gdb --args</code> to its command-line.
e.g.:</p>
<pre><code>gdb --args shadow shadow.config.xml
</code></pre>
<p>An alternative is to run shadow with the <code>-g</code> flag, which will pause shadow
after startup and print the <code>PID</code>. You can then simply attach gdb to shadow in a
new terminal and continue the experiment:</p>
<pre><code>shadow -g shadow.config.xml
# new terminal
gdb --pid=PID
&gt; continue
</code></pre>
<p>Note though, that GDB's <code>follow-fork-mode</code> setting should be left in its default
setting of <code>parent</code>; see below.</p>
<h3 id="debugging-virtual-processes"><a class="header" href="#debugging-virtual-processes">Debugging virtual processes</a></h3>
<p>As of Shadow 2.0, virtual processes in the simulation are implemented as native
OS processes, with their syscalls interposed by Shadow. Since they are native
processes, many normal tools for inspecting native processes can be used on
those as well. e.g. <code>top</code> will show how much CPU and memory they are using.</p>
<p>However, in its default mode of operation, Shadow uses ptrace to control these
processes. Since Linux only allows a process to be ptraced by one other process
at a time, gdb <em>cannot</em> attach to those processes.</p>
<p>If a virtual process is crashing (e.g. being killed by a signal within the
simulation), it is still possible to use gdb to help debug it by causing the
native process to generate a core file, and then using gdb to inspect it
afterwards:</p>
<pre><code># Enable core dumps
ulimit -c unlimited

# Run the simulation in which a process is crashing
shadow shadow.config.xml

# Tell gdb to inspect the core file. From within gdb you'll be able to
# inspect the state of the process just before it was killed. 
gdb &lt;path-to-process-executable&gt; &lt;path-to-core-file&gt;

# It's often useful to look at the stack backtrace:
&gt; bt

# Or for a multi-threaded process, to look at all of the threads' backtraces:
&gt; thread apply all bt
</code></pre>
<h3 id="tracing-shadow-using-valgrind"><a class="header" href="#tracing-shadow-using-valgrind">Tracing Shadow using Valgrind</a></h3>
<p>If you want to be able to run Shadow through valgrind and the application you
are running in Shadow uses OpenSSL (e.g. <code>tor</code>), you should configure OpenSSL
with the additional option: <code>-DPURIFY</code>. This fixes OpenSSL so it doesn't break
valgrind. You may also want to ensure that debugging symbols are included in the
GLib that Shadow links to, and any library used by the plug-in. This can be
achieved with the compiler flag <code>-g</code> when manually building a local version of
GLib.</p>
<h3 id="profiling-shadow"><a class="header" href="#profiling-shadow">Profiling Shadow</a></h3>
<h4 id="profiling-with-gprof"><a class="header" href="#profiling-with-gprof">Profiling with <code>gprof</code></a></h4>
<p>This method only provides profiling info for the core of Shadow, not for
plug-ins, or other libraries. Also, the profiling info is limited since gprof
only measures active CPU usage and function call counts and misses performance
related to blocking IO and barrier waits.</p>
<pre><code class="language-bash">./setup build -cgo
./setup install
cd resource/examples
shadow shadow.config.xml &gt; shadow.log
gprof `which shadow` gmon.out &gt; analysis.txt
less analysis.txt
</code></pre>
<h4 id="profiling-with-perf"><a class="header" href="#profiling-with-perf">Profiling with <code>perf</code></a></h4>
<p>Either run perf when starting Shadow:</p>
<pre><code class="language-bash">perf record shadow shadow.config.yaml &gt; shadow.log
</code></pre>
<p>Or, connect to a running Shadow process:</p>
<pre><code class="language-bash">perf record -p &lt;PID&gt;
</code></pre>
<p>Either of the above two options will write a <code>perf.data</code> file when you press
control-c, or Shadow ends. You can then analyze the report:</p>
<pre><code class="language-bash">perf report
</code></pre>
<p>Perf is extremely powerful with many options. See <code>man perf</code> or <a href="https://perf.wiki.kernel.org/index.php/Tutorial">the perf
wiki</a> for more info.</p>
<p>Note that any time an example uses the <code>-g</code> option in <code>perf record</code>, you should
use <code>--call-graph dwarf</code> instead. (The <code>-g</code> option defaults to stack frames for
traces, which elf-loader and certain optimizations can break. If you see
absurdly tall or small call graphs, this is probably what happened.)</p>
<h3 id="testing-for-deterministic-behavior"><a class="header" href="#testing-for-deterministic-behavior">Testing for Deterministic Behavior</a></h3>
<p>If you run Shadow twice with the same seed (the <code>-s</code> or <code>--seed</code> command line
options), then it <em>should</em> produce deterministic results (it's a bug if it
doesn't).</p>
<p>A good way to check this is to compare the log output of an application that was
run in Shadow. For example, after running two TGen experiments where the results
are in the <code>shadow.data.1</code> and <code>shadow.data.2</code> directories, you could run
something like the following bash script:</p>
<pre><code class="language-bash">#!/bin/bash

found_difference=0

for SUFFIX in \
    hosts/fileserver/stdout-fileserver.tgen.1000.log \
    hosts/client/stdout-client.tgen.1000.log
do
    ## ignore memory addresses in log file with `sed 's/0x[0-9a-f]*/HEX/g' FILENAME`
    sed -i 's/0x[0-9a-f]*/HEX/g' shadow.data.1/${SUFFIX}
    sed -i 's/0x[0-9a-f]*/HEX/g' shadow.data.2/${SUFFIX}

    diff --brief shadow.data.1/${SUFFIX} shadow.data.2/${SUFFIX}
    exit_code=$?

    if (($exit_code != 0)); then
      found_difference=1
    fi
done

if (($found_difference == 1)); then
  echo -e &quot;\033[0;31mDetected difference in output (Shadow may be non-deterministic).\033[0m&quot;
else
  echo -e &quot;\033[0;32mDid not detect difference in Shadow output (Shadow may be deterministic).\033[0m&quot;
fi
</code></pre>
<p>If you find non-deterministic behavior in your Shadow experiment, please
consider helping to diagnose the problem by opening a <a href="https://github.com/shadow/shadow/issues/new">new
issue</a>.</p>
<h3 id="building-the-guide"><a class="header" href="#building-the-guide">Building the Guide</a></h3>
<pre><code class="language-bash">cargo install mdbook
(cd mdbook &amp;&amp; mdbook build)
firefox build/guide/index.html
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration-tests"><a class="header" href="#continuous-integration-tests">Continuous integration tests</a></h1>
<h2 id="on-github"><a class="header" href="#on-github">On GitHub</a></h2>
<p>Our continuous integration tests build and test Shadow on every supported
platform and configuration. GitHub runs these tests automatically when making
or modifying a pull request, in the <a href="../.github/workflows/build_shadow.yml">build and test
workflow</a>. Pull requests without passing
integration tests are blocked from merging.</p>
<h2 id="running-locally"><a class="header" href="#running-locally">Running locally</a></h2>
<p>We also have scripts for running the continuous integration tests locally,
inside Docker containers. This can be useful for debugging and for quickly
iterating on a test that's failing in GitHub's test runs.</p>
<p>The <a href="../ci/run.sh"><code>run.sh</code></a> script builds a Docker images for all
supported configurations, and runs our tests in them.</p>
<p>On the first invocation you should tell the <code>run.sh</code> script to build the images
using <code>-i</code>:</p>
<pre><code class="language-{.bash}">sudo ci/run.sh -i
</code></pre>
<p>If you wish to only check whether the tests pass or fail, future invocations
can omit the <code>-i</code> option to use the existing image and build/test only the
incremental changes. None of the test results will be saved in this case, but
it is much quicker to build.</p>
<p>Note that building all images locally typically takes hours. More often,
you'll want to only run some smaller set of configurations locally.
To run only the configurations you specify, use the <code>-o</code> flag:</p>
<pre><code class="language-{.bash}">sudo ci/run.sh -i -o &quot;ubuntu:18.04;clang;debug fedora:34;gcc;release&quot;
</code></pre>
<p>For additional options, run <code>ci/run.sh -h</code>.</p>
<h2 id="debugging-locally"><a class="header" href="#debugging-locally">Debugging locally</a></h2>
<p>After a local run fails, you can use Docker to help debug it. If you previously
ran the tests without the <code>-i</code> option, re-run with the <code>-i</code> option to rebuild
the Docker image(s). If Shadow was built successfully and the failure happened
at the testing step, then the Docker image was built and tagged, and you can
run an interactive shell in a container built from that image.</p>
<p>e.g.:</p>
<pre><code class="language-{.bash}">sudo docker run --shm-size=1g -it shadow:centos-8-clang-debug /bin/bash
</code></pre>
<p>If the failure happened in the middle of building the Docker image, you can do
the same with the last intermediate layer that was built successfully. e.g.
given the output:</p>
<pre><code class="language-{.bash}">$ sudo ci/run.sh -i -o &quot;centos:8;clang;debug&quot;
&lt;snip&gt;
Step 13/13 : RUN . ci/container_scripts/build_and_install.sh
 ---&gt; Running in a11c4a554ef8
&lt;snip&gt;
    516 [ERROR] Non - zero return code from make.
</code></pre>
<p>You can start a container from the image where Docker tried (and failed) to run
<code>ci/the build_and_install.sh</code> script was executed with:</p>
<pre><code class="language-{.bash}">sudo docker run --shm-size=1g -it a11c4a554ef8 /bin/bash
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>For trivial fixes (e.g. fixing typos or bugs spanning only a few
lines), feel free to send a pull request with your changes.  For
anything bigger than that, it's best to talk to us first.</p>
<p>If you have a specific improvement you'd like to contribute to Shadow, the best
way to get started is to <a href="https://github.com/shadow/shadow/discussions">start a discussion
thread</a>, file an
<a href="https://github.com/shadow/shadow/issues">issue</a> or comment on an existing one.
You can save wasted work this way by ensuring we have agreement on whether
you're planned improvement and design for that improvement fits into the
roadmap for Shadow, and won't conflict with other on-going development.</p>
<p>If you haven't already, it's worth going through the <a href="README.html">general
documentation</a> to get started with building and using
Shadow.</p>
<p>When you're ready to start coding, please take a look at our <a href="coding_style.html">Coding
style</a> and <a href="pull_requests.html">pull request</a>
guidelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-style"><a class="header" href="#coding-style">Coding style</a></h1>
<h2 id="clang-format"><a class="header" href="#clang-format">Clang-format</a></h2>
<p>Our C code formatting style is defined in our
<a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a> <a href="../.clang-format">configuration
file</a>. We try to avoid mass re-formatting, but generally any
lines you modify should be reformatted using <code>clang-format</code>.</p>
<p>To add Ctrl-k as a &quot;format region&quot; in visual and select modes of vim, add the
following to your .vimrc:</p>
<pre><code>vmap &lt;C-K&gt; :py3f /usr/share/vim/addons/syntax/clang-format.py&lt;cr&gt;
</code></pre>
<p>Alternatively you can use the
<a href="https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/git-clang-format">git-clang-format</a>
tool on the command-line to modify the lines touched by your commits.</p>
<h3 id="rustfmt"><a class="header" href="#rustfmt">Rustfmt</a></h3>
<p>To format your Rust code, run <code>cargo fmt</code> once in each Rust crate that you
modify.</p>
<p>Examples:</p>
<pre><code class="language-bash">(cd src/main &amp;&amp; cargo fmt)
(cd src/test &amp;&amp; cargo fmt)
(cd src/lib/logger/rust_bindings &amp;&amp; cargo fmt)
</code></pre>
<h2 id="including-headers"><a class="header" href="#including-headers">Including headers</a></h2>
<h3 id="which-headers-to-include"><a class="header" href="#which-headers-to-include">Which headers to include</a></h3>
<p>Every source and header file should directly include the headers that export
all referenced symbols and macros.</p>
<p>In a C file, includes should be broken into blocks, with the includes sorted
alphabetically within each block. The blocks should occur in this order:</p>
<ul>
<li>The C file's corresponding header; e.g. <code>foo.h</code> for <code>foo.c</code>. This enforces
that the header is self-contained; i.e. doesn't depend on other headers to
be included before it.</li>
<li>System headers are included next to minimize unintentionally exposing any
macros we define to them.</li>
<li>Any other necessary internal headers.</li>
</ul>
<p>This style is loosely based on that used in
<a href="https://wiki.gnome.org/Projects/GTK/BestPractices/GlibIncludes">glib</a> and
supported by the <a href="https://include-what-you-use.org/">include what you use</a>
tool.</p>
<h3 id="inclusion-style"><a class="header" href="#inclusion-style">Inclusion style</a></h3>
<p>Headers included from within the project should use quote-includes, and should
use paths relative to <code>src/</code>. e.g. <code>#include &quot;main/utility/byte_queue.h&quot;</code>, not
<code>#include &quot;byte_queue.h&quot;</code> (even from within the same directory), and not
<code>#include &lt;main/utility/byte_queue.h&gt;</code>.</p>
<p>Headers included external to this repository should use angle-bracket includes.
e.g. <code>#include &lt;glib.h&gt;</code>, not <code>#include &quot;glib.h&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pull-requests-prs"><a class="header" href="#pull-requests-prs">Pull requests (PRs)</a></h1>
<h2 id="clean-commits"><a class="header" href="#clean-commits">Clean commits</a></h2>
<p>Ideally, every commit in history of the <code>main</code> branch should:</p>
<ul>
<li>Be a focused, self-contained change.</li>
<li>Have a commit message that summarizes the change and explains <em>why</em> the change
is being made, if not self-evident.</li>
<li>Build (<code>./setup build --test</code>).</li>
<li>Pass tests (<code>./setup test</code>).</li>
</ul>
<h2 id="drafting-a-pr"><a class="header" href="#drafting-a-pr">Drafting a PR</a></h2>
<p>PRs should be split into smaller, more focused, changes when feasible.
However, we also want to avoid polluting the history with commits that don't
build or pass tests, or commits within a single PR that fix a mistake earlier in
the PR. While iterating on the PR, the <code>--fixup</code> and
<code>--squash</code> flags are useful for committing changes that should ultimately be
merged with one of the earlier commits.</p>
<p>When creating a pull request, we suggest you first create it as a
<a href="https://github.blog/2019-02-14-introducing-draft-pull-requests/">draft</a>.  This
will still trigger our continuous-integration checks, and give you a chance
resolve any issues with those (i.e. broken tests) before requesting review.</p>
<p>Once done iterating, first consider using <code>git rebase -i --autosquash</code> to clean
up your commit history, and then force pushing to update your PR.  Finally, take
the pull request out of draft mode to signal that you're ready for review.</p>
<h2 id="responding-to-review-feedback"><a class="header" href="#responding-to-review-feedback">Responding to review feedback</a></h2>
<p><em>During</em> PR review, please do not rebase or force-push, since this makes it
difficult to see what's changed between rounds of review. Consider using
<code>--fixup</code> and <code>--squash</code> for commits responding to review feedback, so that they
can be appropriately squashed before the final merge. <a href="https://github.com/torbiak/git-autofixup/">git autofixup</a> can also be useful for generating
<code>--fixup</code> commits.</p>
<h2 id="merging"><a class="header" href="#merging">Merging</a></h2>
<p>When the PR is ready to be merged, the reviewer might ask you to <code>git rebase</code>
and force push to clean up history, or might do it themselves.</p>
<p>For the maintainer doing the merge:</p>
<p>If the PR is relatively small, or if it's not worth the effort of rewriting
history into clean commits, use the &quot;squash and merge&quot; strategy.</p>
<p>If the individual commits appear to be useful to keep around in our history,
instead use the &quot;create a merge commit&quot; strategy. There's no need to review
every individual commit when using this strategy, but if the intermediate
commits are obviously low quality consider using the &quot;squash and merge strategy&quot;
instead. Note that since this strategy creates a merge commit, we can still
later identify and filter out the intermediate commits if desired, e.g. with
<code>git log --first-parent main</code>.</p>
<p>We've disabled the &quot;Rebase and merge&quot; option, since it does a fast-forward
merge, which makes the intermediate commits indistingishuable from the validated
and reviewed final state of the PR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maintainer-playbook"><a class="header" href="#maintainer-playbook">Maintainer playbook</a></h1>
<h2 id="tagging-shadow-releases"><a class="header" href="#tagging-shadow-releases">Tagging Shadow releases</a></h2>
<p>We use <a href="https://semver.org/">Semantic Versioning</a>, and increment version
numbers with the <a href="https://pypi.org/project/bumpversion/">bumpversion</a> tool.</p>
<p>The following commands can be used to tag a new version of Shadow, after which
an archive will be available on github's <a href="https://github.com/shadow/shadow/releases">releases
page</a>.</p>
<pre><code class="language-bash">git checkout main

# Bump the patch, minor, or major version number, commit the change, and tag
# that commit.
bumpversion &lt;patch|minor|major&gt; --tag --commit

# Get the new version number.
VERSION=`awk -F &quot;=&quot; '/current_version/ {print $2}' .bumpversion.cfg | tr -d ' '`

# Update the Cargo lock files, then update the commit and tag
(cd src/main &amp;&amp; cargo update --workspace)
(cd src/test &amp;&amp; cargo update --workspace)
git add src/main/Cargo.lock src/test/Cargo.lock
git commit --amend --no-edit
git tag -f -a &quot;v$VERSION&quot;

# Push to GitHub.
git push origin &quot;v$VERSION&quot;
</code></pre>
<p>Our releases will then be tagged off of the main branch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="national-science-foundation-sponsorship"><a class="header" href="#national-science-foundation-sponsorship">National Science Foundation Sponsorship</a></h1>
<p><strong>Project Title:</strong> Expanding Research Frontiers with a Next-Generation Anonymous Communication Experimentation (ACE) Framework</p>
<p><strong>Project Period:</strong> October 1, 2019 - September 30, 2022</p>
<p><strong>Abstract:</strong> <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1925497">NSF Award Abstract #1925497</a></p>
<p>The goal of this project is to develop a scalable and mature deterministic
network simulator, capable of quickly and accurately simulating large networks
such as <a href="https://www.torproject.org">Tor</a>. This project builds on <a href="https://shadow.github.io/">the Shadow
Simulator</a>.</p>
<h2 id="nsf-project-overview"><a class="header" href="#nsf-project-overview">NSF Project Overview</a></h2>
<p>ACE will be developed with the following features:</p>
<ul>
<li><strong>Application Emulation.</strong> Learning from the community’s experience, ACE will
directly execute software and run applications as normal operating system
processes. By supporting the general execution of applications (i.e.,
anything that can be executed as a process: network servers, web browsers,
scripts, etc.), ACE will support software independent of the programming
language chosen by developers, and ACE will maximize its applicability to a
large range of evaluation approaches that CISE researchers choose to utilize.
As a result, ACE will be well-suited to website fingerprinting and censorship
circumvention research focus areas, which typically require running a variety
of tools written in a variety of languages.</li>
<li><strong>Network Simulation.</strong> ACE will feature a light-weight network simulation
component that will allow applications to communicate with each other through
the ACE framework rather than over the Internet. ACE will simulate common
transport protocols, such as TCP and UDP. ACE will also simulate virtual
network routers and other network path components between end-hosts, and
support evaluation under dynamic changes to timing, congestion, latency,
bandwidth, network location, and network path elements. Therefore, ACE will
support both network-aware and location-aware anonymous communication
research and allow researchers to continue to advance this research agenda in
current and future Internet architectures.</li>
<li><strong>Function Interposition.</strong> ACE will utilize function interposition in order
to connect the processes being run by the operating system to the core
network simulation component. ACE will support an API of common system calls
that are used to, e.g., send and receive data to and from the network.
Therefore, all processes executed in ACE will be isolated from the Internet
and connected through ACE’s simulated network, and the simulation component
will drive process execution.</li>
<li><strong>Controlled, Deterministic Execution.</strong> ACE features a deterministic
discrete-event engine, and will therefore control time and operate in
simulated timescales. As a result, ACE will be disconnected from the
computational abilities of the host machine: ACE will run
as-fast-as-possible, which could be faster or slower than real time depending
on experiment load. ACE is deterministic so that research results can be
independently and identically reproduced and verified across research labs.</li>
<li><strong>Parallel and Distributed Execution.</strong> ACE will rely on the operating system
kernel to run and manage processes. Operating system kernels have been
optimized for this task, and ACE will benefit in terms of better performance
and a smaller code base. Moreover, ACE will be embarrassingly parallel: the
Linux kernel generally scales to millions of processes that can be run in
parallel, and we will design ACE such that any number of processes can be
executed across multiple distinct machines. Therefore, ACE will scale to
realistically-sized anonymous communication networks containing millions of
virtual hosts, and can be deployed on whatever existing infrastructure is
available at community members' institutions.</li>
</ul>
<p>As part of the ACE framework, we will also develop a <strong>user interface</strong> to
control and monitor the experimental process, a <strong>toolkit</strong> to help users set up
and configure experiments (including network, mobility, and traffic
characteristics and models) and to visualize results, and a <strong>data repository</strong>
where researchers can share and archive experimental results.</p>
<h2 id="project-goalsactivities"><a class="header" href="#project-goalsactivities">Project Goals/Activities</a></h2>
<p>Here we outline some high level tasks that we are completing or plan to complete
under this project. We are using Github for project development, including for
tracking progress on major milestones and development tasks. We provide an
outline of our agenda here, and link to the appropriate Github page where
appropriate. Tasks without corresponding Github links means we don't yet have
progress to share at this time.</p>
<ul>
<li>
<p><strong>Task 0: Investigate Architectural Improvements</strong></p>
<ul>
<li>Build prototype of a process-based simulation architecture -
<a href="https://github.com/shadow/shadow/milestone/16">milestone</a></li>
<li>Evaluate and compare against a plugin-based simulation architecture</li>
<li>Decide which architecture is right for ACE</li>
</ul>
</li>
<li>
<p><strong>Task 1: Develop Core ACE System</strong></p>
<ul>
<li>Improve test coverage and infrastructure - <a href="https://github.com/shadow/shadow/milestone/15">shadow
milestone</a>,
<a href="https://github.com/shadow/shadow-plugin-tor/milestone/1">shadow-plugin-tor
milestone</a></li>
<li>Enable new code to be written in Rust -
<a href="https://github.com/shadow/shadow/milestone/17">milestone</a></li>
<li>Improve consistency of simulation options and configuration</li>
<li>Improve maintainability and accuracy of TCP implementation -
<a href="https://github.com/shadow/shadow/milestone/18">milestone</a></li>
<li>Simplify event scheduler, implement continuous event execution model</li>
<li>Build a distributed core simulation engine</li>
<li>Develop CPU usage model to ensure virtual process CPU utilization consumes
simulation time</li>
</ul>
</li>
<li>
<p><strong>Task 2: Develop User Interface and Visualizations</strong></p>
<ul>
<li>Design control protocol and API for interacting with Shadow</li>
<li>Specify/document protocol</li>
<li>Develop user interface that uses the control API</li>
<li>Improve tools for analyzing and understanding simulation results</li>
</ul>
</li>
<li>
<p><strong>Task 3: Develop Simulation Models for ACE</strong></p>
<ul>
<li>Improve tools for generating and configuring private Tor networks</li>
<li>Improve tools for generating and configuring background traffic models</li>
<li>Improve tools for modeling Internet paths and latency</li>
<li>Develop support for mobile hosts</li>
<li>Create realistic host mobility models</li>
</ul>
</li>
<li>
<p><strong>Task 4: Engage Community</strong></p>
<ul>
<li>Create data repository where users can share configs and results</li>
<li>Create user outreach material and surveys to collect feedback</li>
<li>Improve user documentation and usage instructions</li>
</ul>
</li>
</ul>
<p>Over all tasks, we plan to significantly improve documentation, test coverage,
and code maintainability.</p>
<h2 id="people"><a class="header" href="#people">People</a></h2>
<ul>
<li><a href="https://www.robgjansen.com">Rob Jansen</a> - Project Leader, Principal
Investigator, U.S. Naval Research Laboratory</li>
<li>Roger Dingledine - Principal Investigator, The Tor Project</li>
<li>Micah Sherr - Principal Investigator, Georgetown University</li>
<li>Jim Newsome - Developer, The Tor Project</li>
<li>Steven Engler - Developer, Georgetown University / The Tor Project</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
