searchState.loadedDescShard("lzma_rs", 0, "Pure-Rust codecs for LZMA, LZMA2, and XZ.\nCompression helpers.\nDecompression helpers.\nError handling.\nCompress data with LZMA2 and default <code>Options</code>.\nDecompress LZMA2 data with default <code>Options</code>.\nCompresses data with LZMA and default <code>Options</code>.\nCompress LZMA data with the provided options.\nDecompress LZMA data with default <code>Options</code>.\nDecompress LZMA data with the provided options.\nCompress data with XZ and default <code>Options</code>.\nDecompress XZ data with default <code>Options</code>.\nOptions for the <code>lzma_compress</code> function\nDo not write anything to the header. The unpacked size …\nAlternatives for handling unpacked size\nIf the value is <code>Some(u64)</code>, write the provided u64 value to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDefines whether the unpacked size should be written to the …\nOptions to tweak decompression behavior.\nAssume that the 8 bytes used to specify the unpacked size …\nAssume that there are 8 bytes representing the unpacked …\nAlternatives for defining the unpacked size of the decoded …\nAssume that the 8 bytes typically used to represent the …\nDetermines whether to bypass end of stream validation.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDefines whether the dictionary’s dynamic size should be …\nDefines whether the unpacked size should be read from the …\nContains the error value\nLibrary errors.\nNot enough bytes to complete header\nI/O error.\nLZMA error.\nContains the success value\nLibrary result alias.\nXZ error.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")