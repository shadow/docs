<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Procedural macros to be used with the library `neli`."><title>neli_proc_macros - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="neli_proc_macros" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../neli_proc_macros/index.html">neli_proc_macros</a><span class="version">0.1.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#attributes">Attribute Macros</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">neli_proc_macros</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/neli_proc_macros/lib.rs.html#1-205">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Procedural macros to be used with the library
<a href="https://github.com/jbaublitz/neli"><code>neli</code></a>.</p>
<p>All derive macros other than <code>Header</code> generate implicit type
parameter bounds on every type parameter which can be overriden
with struct attributes.</p>
</div></details><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.neli_enum.html" title="attr neli_proc_macros::neli_enum">neli_enum</a></div><div class="desc docblock-short">Converts an enum from the form:</div></li></ul><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.FromBytes.html" title="derive neli_proc_macros::FromBytes">FromBytes</a></div><div class="desc docblock-short">Derives the neli <code>FromBytes</code> trait for a struct.</div></li><li><div class="item-name"><a class="derive" href="derive.FromBytesWithInput.html" title="derive neli_proc_macros::FromBytesWithInput">FromBytesWithInput</a></div><div class="desc docblock-short">Derives the neli <code>FromBytesWithInput</code> trait for a struct.</div></li><li><div class="item-name"><a class="derive" href="derive.Header.html" title="derive neli_proc_macros::Header">Header</a></div><div class="desc docblock-short">Derives the neli <code>Header</code> trait for a struct or enum. Unlike
other derive macros in this crate, the <code>Header</code> derive macro
does not impose type parameter bounds on type parameters.
See the accepted attribute for more information. The reason for
this is that the last field is considered to be the payload.
Because the payload may be represented by a type parameter,
we cannot blindly restrict type parameters or else we impose
an artificial restriction of <code>TypeSize</code> on the payload type
parameter. This is a problem for the <code>Header</code> trait as the
payload may be unsized even if the rest of the header is
composed exclusively of statically sized types and are therefore
compatible with the <code>TypeSize</code> trait.</div></li><li><div class="item-name"><a class="derive" href="derive.Size.html" title="derive neli_proc_macros::Size">Size</a></div><div class="desc docblock-short">Derives the neli <code>Size</code> trait for a struct or enum.</div></li><li><div class="item-name"><a class="derive" href="derive.ToBytes.html" title="derive neli_proc_macros::ToBytes">ToBytes</a></div><div class="desc docblock-short">Derives the neli <code>ToBytes</code> trait for a struct or enum.</div></li></ul></section></div></main></body></html>