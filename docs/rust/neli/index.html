<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="neli: Type safety for netlink"><title>neli - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="neli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../neli/index.html">neli</a><span class="version">0.6.4</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#attributes">Attribute Macros</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../neli/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">neli</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/neli/lib.rs.html#1-701">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="neli-type-safety-for-netlink"><a href="#neli-type-safety-for-netlink">neli: Type safety for netlink</a></h2><h3 id="rationale"><a href="#rationale">Rationale</a></h3>
<p>This crate aims to be a pure Rust implementation that defines
the necessary constants and wraps them in enums to distinguish
between various categories of constants in the context of netlink.</p>
<h3 id="the-project-is-broken-down-into-the-following-modules"><a href="#the-project-is-broken-down-into-the-following-modules">The project is broken down into the following modules:</a></h3>
<ul>
<li><code>attr</code> - This defines a generic interface for netlink attributes
(both generic and routing netlink attributes).</li>
<li><code>consts</code> - This is where all of the C-defined constants are
wrapped into type safe enums for use in the library.</li>
<li><code>err</code> - This module contains all of the protocol and
library-level errors encountered in the code.</li>
<li><code>genl</code> - This code provides parsing for the generic netlink</li>
<li><code>iter</code> - This code handles iterating over received netlink
packets.</li>
<li><code>nl</code> - This is the top level netlink header code that handles
the header that all netlink messages are encapsulated in.</li>
<li><code>rtnl</code> - This module is for the routing netlink subsystem of the
netlink protocol.</li>
<li><code>socket</code> - This provides a socket structure for use in sending
and receiving messages and a number of convenience functions for
commonly encountered use cases.</li>
<li><code>types</code> - Data types used in serialization and deserialization of
packets.</li>
<li><code>utils</code> - Data types that primarily serve the purpose of handling
kernel data format conversions to easily usable Rust constructs
for the user.</li>
</ul>
<h3 id="design-decisions"><a href="#design-decisions">Design decisions</a></h3>
<p>This is a fairly low level library that currently does not have a
whole lot of higher level handle-type data structures and
relies mostly on the <a href="socket/struct.NlSocket.html" title="struct neli::socket::NlSocket"><code>NlSocket</code></a> and
<a href="socket/struct.NlSocketHandle.html" title="struct neli::socket::NlSocketHandle"><code>NlSocketHandle</code></a> structs
to provide most of the convenience functions.</p>
<p>The goal of this library is completeness for handling netlink and
am working to incorporate features that will make this library
easier to use in all use cases. If you have a use case you
would like to see supported, please open an issue on Github.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>Examples of working code exist in the <code>examples/</code> subdirectory on
Github. Run <code>cargo build --examples</code> to build the examples.</p>
<p>Workflows usually follow a pattern of socket creation, and
then either sending and receiving messages in request/response
formats:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;

<span class="kw">use </span>neli::{
    consts::{genl::<span class="kw-2">*</span>, nl::<span class="kw-2">*</span>, socket::<span class="kw-2">*</span>},
    err::NlError,
    genl::{Genlmsghdr, Nlattr},
    nl::{Nlmsghdr, NlPayload},
    socket::NlSocketHandle,
    types::{Buffer, GenlBuffer},
};

<span class="kw">const </span>GENL_VERSION: u8 = <span class="number">1</span>;

<span class="kw">fn </span>request_response() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>socket = NlSocketHandle::connect(
        NlFamily::Generic,
        <span class="prelude-val">None</span>,
        <span class="kw-2">&amp;</span>[],
    )<span class="question-mark">?</span>;

    <span class="kw">let </span>attrs: GenlBuffer&lt;Index, Buffer&gt; = GenlBuffer::new();
    <span class="kw">let </span>genlhdr = Genlmsghdr::new(
        CtrlCmd::Getfamily,
        GENL_VERSION,
        attrs,
    );
    <span class="kw">let </span>nlhdr = {
        <span class="kw">let </span>len = <span class="prelude-val">None</span>;
        <span class="kw">let </span>nl_type = GenlId::Ctrl;
        <span class="kw">let </span>flags = NlmFFlags::new(<span class="kw-2">&amp;</span>[NlmF::Request, NlmF::Dump]);
        <span class="kw">let </span>seq = <span class="prelude-val">None</span>;
        <span class="kw">let </span>pid = <span class="prelude-val">None</span>;
        <span class="kw">let </span>payload = NlPayload::Payload(genlhdr);
        Nlmsghdr::new(len, nl_type, flags, seq, pid, payload)
    };
    socket.send(nlhdr)<span class="question-mark">?</span>;
     
    <span class="comment">// Do things with multi-message response to request...
    </span><span class="kw">let </span><span class="kw-2">mut </span>iter = socket.iter::&lt;NlTypeWrapper, Genlmsghdr&lt;CtrlCmd, CtrlAttr&gt;&gt;(<span class="bool-val">false</span>);
    <span class="kw">while let </span><span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(response)) = iter.next() {
        <span class="comment">// Do things with response here...
    </span>}
     
    <span class="comment">// Or get single message back...
    </span><span class="kw">let </span>msg = socket.recv::&lt;Nlmsg, Genlmsghdr&lt;CtrlCmd, CtrlAttr&gt;&gt;()<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>or a subscriptions to a stream of event notifications from netlink:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::error::Error;

<span class="kw">use </span>neli::{
    consts::{genl::<span class="kw-2">*</span>, nl::<span class="kw-2">*</span>, socket::<span class="kw-2">*</span>},
    err::NlError,
    genl::Genlmsghdr,
    socket,
};

<span class="kw">fn </span>subscribe_to_mcast() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>s = socket::NlSocketHandle::connect(
        NlFamily::Generic,
        <span class="prelude-val">None</span>,
        <span class="kw-2">&amp;</span>[],
    )<span class="question-mark">?</span>;
    <span class="kw">let </span>id = s.resolve_nl_mcast_group(
        <span class="string">"my_family_name"</span>,
        <span class="string">"my_multicast_group_name"</span>,
    )<span class="question-mark">?</span>;
    s.add_mcast_membership(<span class="kw-2">&amp;</span>[id])<span class="question-mark">?</span>;
    <span class="kw">for </span>next <span class="kw">in </span>s.iter::&lt;NlTypeWrapper, Genlmsghdr&lt;u8, u16&gt;&gt;(<span class="bool-val">true</span>) {
        <span class="comment">// Do stuff here with parsed packets...
     
        // like printing a debug representation of them:
        </span><span class="macro">println!</span>(<span class="string">"{:?}"</span>, next<span class="question-mark">?</span>);
    }

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="documentation"><a href="#documentation">Documentation</a></h3>
<p>Each module has been documented extensively to provide information
on how to use the code contained in the module. Pull requests for
documentation mistakes, updates, and rewording for clarity is a
valuable contribution as this project aims to be as simple to use
as possible.</p>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="attr/index.html" title="mod neli::attr">attr</a></div><div class="desc docblock-short">Shared attribute code for all types of netlink attributes.</div></li><li><div class="item-name"><a class="mod" href="consts/index.html" title="mod neli::consts">consts</a></div><div class="desc docblock-short">High level notes</div></li><li><div class="item-name"><a class="mod" href="err/index.html" title="mod neli::err">err</a></div><div class="desc docblock-short">This is the module that contains the error types used in <code>neli</code></div></li><li><div class="item-name"><a class="mod" href="genl/index.html" title="mod neli::genl">genl</a></div><div class="desc docblock-short">This module contains generic netlink parsing data structures.
This is all handled by the <a href="genl/struct.Genlmsghdr.html" title="struct neli::genl::Genlmsghdr"><code>Genlmsghdr</code></a>
header struct which contains all of the information needed for
the generic netlink layer.</div></li><li><div class="item-name"><a class="mod" href="iter/index.html" title="mod neli::iter">iter</a></div><div class="desc docblock-short">Module for iteration over netlink responses</div></li><li><div class="item-name"><a class="mod" href="nl/index.html" title="mod neli::nl">nl</a></div><div class="desc docblock-short">This module contains the top level netlink header code. Every
netlink message will be encapsulated in a top level <code>Nlmsghdr</code>.</div></li><li><div class="item-name"><a class="mod" href="rtnl/index.html" title="mod neli::rtnl">rtnl</a></div><div class="desc docblock-short">This module provides an implementation of routing netlink
structures and the routing attributes that are at the end of
most routing netlink responses.</div></li><li><div class="item-name"><a class="mod" href="socket/index.html" title="mod neli::socket">socket</a></div><div class="desc docblock-short">This module provides code that glues all of the other modules
together and allows message send and receive operations.</div></li><li><div class="item-name"><a class="mod" href="types/index.html" title="mod neli::types">types</a></div><div class="desc docblock-short">Module containing various types used across the various netlink
structures used in <code>neli</code>.</div></li><li><div class="item-name"><a class="mod" href="utils/index.html" title="mod neli::utils">utils</a></div><div class="desc docblock-short">A module containing utilities for working with constructs like
bitflags and other low level operations.</div></li></ul><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.impl_flags.html" title="macro neli::impl_flags">impl_flags</a></div><div class="desc docblock-short">Implement a container for bit flag enums where the set of flags
will be condensed into a single value.</div></li><li><div class="item-name"><a class="macro" href="macro.impl_trait.html" title="macro neli::impl_trait">impl_trait</a></div><div class="desc docblock-short">For generating a marker trait that flags a new enum as usable in a
field that accepts a generic type. This way, the type parameter
can be constrained by a trait bound to only accept enums that
implement the marker trait.</div></li></ul><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BeU64.html" title="struct neli::BeU64">BeU64</a></div><div class="desc docblock-short">A <code>u64</code> data type that will always be serialized as big endian</div></li></ul><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.FromBytes.html" title="trait neli::FromBytes">FromBytes</a></div><div class="desc docblock-short">A trait defining how to convert from a byte buffer to a netlink
data structure.</div></li><li><div class="item-name"><a class="trait" href="trait.FromBytesWithInput.html" title="trait neli::FromBytesWithInput">FromBytesWithInput</a></div><div class="desc docblock-short">Takes an arbitrary input which serves as additional information
for guiding the conversion from a byte buffer to a data
structure. A common workflow is a data structure that has a size
to determine how much more of the data in the byte buffer is
part of a given data structure.</div></li><li><div class="item-name"><a class="trait" href="trait.Header.html" title="trait neli::Header">Header</a></div><div class="desc docblock-short">Defined for data structures that contain a header.</div></li><li><div class="item-name"><a class="trait" href="trait.Size.html" title="trait neli::Size">Size</a></div><div class="desc docblock-short">A trait defining methods that apply to all netlink data
structures related to sizing of data types.</div></li><li><div class="item-name"><a class="trait" href="trait.ToBytes.html" title="trait neli::ToBytes">ToBytes</a></div><div class="desc docblock-short">A trait defining a netlink data structure’s conversion to
a byte buffer.</div></li><li><div class="item-name"><a class="trait" href="trait.TypeSize.html" title="trait neli::TypeSize">TypeSize</a></div><div class="desc docblock-short">A trait defining methods that apply to constant-sized
data types related to size.</div></li></ul><h2 id="attributes" class="section-header"><a href="#attributes">Attribute Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.neli_enum.html" title="attr neli::neli_enum">neli_enum</a></div><div class="desc docblock-short">Converts an enum from the form:</div></li></ul><h2 id="derives" class="section-header"><a href="#derives">Derive Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.FromBytes.html" title="derive neli::FromBytes">FromBytes</a></div><div class="desc docblock-short">Derives the neli <code>FromBytes</code> trait for a struct.</div></li><li><div class="item-name"><a class="derive" href="derive.FromBytesWithInput.html" title="derive neli::FromBytesWithInput">FromBytesWithInput</a></div><div class="desc docblock-short">Derives the neli <code>FromBytesWithInput</code> trait for a struct.</div></li><li><div class="item-name"><a class="derive" href="derive.Header.html" title="derive neli::Header">Header</a></div><div class="desc docblock-short">Derives the neli <code>Header</code> trait for a struct or enum. Unlike
other derive macros in this crate, the <code>Header</code> derive macro
does not impose type parameter bounds on type parameters.
See the accepted attribute for more information. The reason for
this is that the last field is considered to be the payload.
Because the payload may be represented by a type parameter,
we cannot blindly restrict type parameters or else we impose
an artificial restriction of <code>TypeSize</code> on the payload type
parameter. This is a problem for the <code>Header</code> trait as the
payload may be unsized even if the rest of the header is
composed exclusively of statically sized types and are therefore
compatible with the <code>TypeSize</code> trait.</div></li><li><div class="item-name"><a class="derive" href="derive.Size.html" title="derive neli::Size">Size</a></div><div class="desc docblock-short">Derives the neli <code>Size</code> trait for a struct or enum.</div></li><li><div class="item-name"><a class="derive" href="derive.ToBytes.html" title="derive neli::ToBytes">ToBytes</a></div><div class="desc docblock-short">Derives the neli <code>ToBytes</code> trait for a struct or enum.</div></li></ul></section></div></main></body></html>